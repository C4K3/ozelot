/* This file is automatically generated by packets.clj
Do not manually edit this file, if you wish to make
changes here, then edit and rerun packets.clj */

#[derive(Debug, PartialEq, Clone)]
pub struct Handshake {
    protocol_version: i32,
    server_address: String,
    server_port: u16,
    next_state: i32,
}

impl Handshake {
    fn get_packet_id() -> i32 {
        0
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::Handshake(Handshake {
            protocol_version: read_varint(r)?,
            server_address: read_String(r)?,
            server_port: read_u16(r)?,
            next_state: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Handshake::get_packet_id(), &mut ret)?;
        write_varint(&self.protocol_version, &mut ret)?;
        write_String(&self.server_address, &mut ret)?;
        write_u16(&self.server_port, &mut ret)?;
        write_varint(&self.next_state, &mut ret)?;

        Ok(ret)
    }
    pub fn new(protocol_version: i32, server_address: String, server_port: u16, next_state: i32) -> ServerboundPacket {
        ServerboundPacket::Handshake(Handshake {
            protocol_version: protocol_version,
            server_address: server_address,
            server_port: server_port,
            next_state: next_state,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusRequest {
}

impl StatusRequest {
    fn get_packet_id() -> i32 {
        0
    }


    pub fn new_raw() -> ServerboundPacket {
        ServerboundPacket::StatusRequest(StatusRequest {
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusPing {
    id: u64,
}

impl StatusPing {
    fn get_packet_id() -> i32 {
        1
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::StatusPing(StatusPing {
            id: read_u64(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&StatusPing::get_packet_id(), &mut ret)?;
        write_u64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: u64) -> ServerboundPacket {
        ServerboundPacket::StatusPing(StatusPing {
            id: id,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginStart {
    name: String,
}

impl LoginStart {
    fn get_packet_id() -> i32 {
        0
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::LoginStart(LoginStart {
            name: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&LoginStart::get_packet_id(), &mut ret)?;
        write_String(&self.name, &mut ret)?;

        Ok(ret)
    }
    pub fn new(name: String) -> ServerboundPacket {
        ServerboundPacket::LoginStart(LoginStart {
            name: name,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EncryptionResponse {
    shared_secret: Vec<u8>,
    verify_token: Vec<u8>,
}

impl EncryptionResponse {
    fn get_packet_id() -> i32 {
        1
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::EncryptionResponse(EncryptionResponse {
            shared_secret: read_prefixed_bytearray(r)?,
            verify_token: read_prefixed_bytearray(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EncryptionResponse::get_packet_id(), &mut ret)?;
        write_prefixed_bytearray(&self.shared_secret, &mut ret)?;
        write_prefixed_bytearray(&self.verify_token, &mut ret)?;

        Ok(ret)
    }
    pub fn new(shared_secret: Vec<u8>, verify_token: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::EncryptionResponse(EncryptionResponse {
            shared_secret: shared_secret,
            verify_token: verify_token,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct TeleportConfirm {
    id: i32,
}

impl TeleportConfirm {
    fn get_packet_id() -> i32 {
        0
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::TeleportConfirm(TeleportConfirm {
            id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&TeleportConfirm::get_packet_id(), &mut ret)?;
        write_varint(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i32) -> ServerboundPacket {
        ServerboundPacket::TeleportConfirm(TeleportConfirm {
            id: id,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct TabComplete {
    text: String,
    assume_command: bool,
    looked_at_block: Option<(i32, i32, i32)>,
}

impl TabComplete {
    fn get_packet_id() -> i32 {
        1
    }


    pub fn new_raw(text: String, assume_command: bool, looked_at_block: Option<(i32, i32, i32)>) -> ServerboundPacket {
        ServerboundPacket::TabComplete(TabComplete {
            text: text,
            assume_command: assume_command,
            looked_at_block: looked_at_block,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ChatMessage {
    message: String,
}

impl ChatMessage {
    fn get_packet_id() -> i32 {
        2
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::ChatMessage(ChatMessage {
            message: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ChatMessage::get_packet_id(), &mut ret)?;
        write_String(&self.message, &mut ret)?;

        Ok(ret)
    }
    pub fn new(message: String) -> ServerboundPacket {
        ServerboundPacket::ChatMessage(ChatMessage {
            message: message,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientStatus {
    action: i32,
}

impl ClientStatus {
    fn get_packet_id() -> i32 {
        3
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClientStatus(ClientStatus {
            action: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientStatus::get_packet_id(), &mut ret)?;
        write_varint(&self.action, &mut ret)?;

        Ok(ret)
    }
    pub fn new(action: i32) -> ServerboundPacket {
        ServerboundPacket::ClientStatus(ClientStatus {
            action: action,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientSettings {
    locale: String,
    view_distance: u8,
    chat_mode: i32,
    chat_colors: bool,
    displayed_skin_parts: u8,
    main_hand: i32,
}

impl ClientSettings {
    fn get_packet_id() -> i32 {
        4
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClientSettings(ClientSettings {
            locale: read_String(r)?,
            view_distance: read_u8(r)?,
            chat_mode: read_varint(r)?,
            chat_colors: read_bool(r)?,
            displayed_skin_parts: read_u8(r)?,
            main_hand: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientSettings::get_packet_id(), &mut ret)?;
        write_String(&self.locale, &mut ret)?;
        write_u8(&self.view_distance, &mut ret)?;
        write_varint(&self.chat_mode, &mut ret)?;
        write_bool(&self.chat_colors, &mut ret)?;
        write_u8(&self.displayed_skin_parts, &mut ret)?;
        write_varint(&self.main_hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(locale: String, view_distance: u8, chat_mode: i32, chat_colors: bool, displayed_skin_parts: u8, main_hand: i32) -> ServerboundPacket {
        ServerboundPacket::ClientSettings(ClientSettings {
            locale: locale,
            view_distance: view_distance,
            chat_mode: chat_mode,
            chat_colors: chat_colors,
            displayed_skin_parts: displayed_skin_parts,
            main_hand: main_hand,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ConfirmTransaction {
    window_id: u8,
    id: i16,
    accepted: bool,
}

impl ConfirmTransaction {
    fn get_packet_id() -> i32 {
        5
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::ConfirmTransaction(ConfirmTransaction {
            window_id: read_u8(r)?,
            id: read_i16(r)?,
            accepted: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ConfirmTransaction::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.id, &mut ret)?;
        write_bool(&self.accepted, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, id: i16, accepted: bool) -> ServerboundPacket {
        ServerboundPacket::ConfirmTransaction(ConfirmTransaction {
            window_id: window_id,
            id: id,
            accepted: accepted,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EnchantItem {
    window_id: u8,
    enchantment: i8,
}

impl EnchantItem {
    fn get_packet_id() -> i32 {
        6
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::EnchantItem(EnchantItem {
            window_id: read_u8(r)?,
            enchantment: read_i8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EnchantItem::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i8(&self.enchantment, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, enchantment: i8) -> ServerboundPacket {
        ServerboundPacket::EnchantItem(EnchantItem {
            window_id: window_id,
            enchantment: enchantment,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClickWindow {
    window_id: u8,
    slot_id: i16,
    button: i8,
    id: i16,
    mode: i32,
    slot: Vec<u8>,
}

impl ClickWindow {
    fn get_packet_id() -> i32 {
        7
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClickWindow(ClickWindow {
            window_id: read_u8(r)?,
            slot_id: read_i16(r)?,
            button: read_i8(r)?,
            id: read_i16(r)?,
            mode: read_varint(r)?,
            slot: read_bytearray(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClickWindow::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_i8(&self.button, &mut ret)?;
        write_i16(&self.id, &mut ret)?;
        write_varint(&self.mode, &mut ret)?;
        write_bytearray(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, slot_id: i16, button: i8, id: i16, mode: i32, slot: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::ClickWindow(ClickWindow {
            window_id: window_id,
            slot_id: slot_id,
            button: button,
            id: id,
            mode: mode,
            slot: slot,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct CloseWindow {
    window_id: u8,
}

impl CloseWindow {
    fn get_packet_id() -> i32 {
        8
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::CloseWindow(CloseWindow {
            window_id: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&CloseWindow::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8) -> ServerboundPacket {
        ServerboundPacket::CloseWindow(CloseWindow {
            window_id: window_id,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PluginMessage {
    channel: String,
    data: Vec<u8>,
}

impl PluginMessage {
    fn get_packet_id() -> i32 {
        9
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::PluginMessage(PluginMessage {
            channel: read_String(r)?,
            data: read_bytearray(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PluginMessage::get_packet_id(), &mut ret)?;
        write_String(&self.channel, &mut ret)?;
        write_bytearray(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(channel: String, data: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::PluginMessage(PluginMessage {
            channel: channel,
            data: data,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct UseEntity {
    target: i32,
    action: i32,
    location: Option<(f32, f32, f32)>,
    hand: Option<i32>,
}

impl UseEntity {
    fn get_packet_id() -> i32 {
        10
    }


    pub fn new_raw(target: i32, action: i32, location: Option<(f32, f32, f32)>, hand: Option<i32>) -> ServerboundPacket {
        ServerboundPacket::UseEntity(UseEntity {
            target: target,
            action: action,
            location: location,
            hand: hand,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct KeepAlive {
    id: i32,
}

impl KeepAlive {
    fn get_packet_id() -> i32 {
        11
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::KeepAlive(KeepAlive {
            id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&KeepAlive::get_packet_id(), &mut ret)?;
        write_varint(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i32) -> ServerboundPacket {
        ServerboundPacket::KeepAlive(KeepAlive {
            id: id,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPosition {
    x: f64,
    y: f64,
    z: f64,
    on_ground: bool,
}

impl PlayerPosition {
    fn get_packet_id() -> i32 {
        12
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerPosition(PlayerPosition {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerPosition::get_packet_id(), &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerPosition(PlayerPosition {
            x: x,
            y: y,
            z: z,
            on_ground: on_ground,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPositionAndLook {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
    on_ground: bool,
}

impl PlayerPositionAndLook {
    fn get_packet_id() -> i32 {
        13
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerPositionAndLook::get_packet_id(), &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerLook {
    yaw: f32,
    pitch: f32,
    on_ground: bool,
}

impl PlayerLook {
    fn get_packet_id() -> i32 {
        14
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerLook(PlayerLook {
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerLook::get_packet_id(), &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(yaw: f32, pitch: f32, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerLook(PlayerLook {
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Player {
    on_ground: bool,
}

impl Player {
    fn get_packet_id() -> i32 {
        15
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::Player(Player {
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Player::get_packet_id(), &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::Player(Player {
            on_ground: on_ground,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct VehicleMove {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
}

impl VehicleMove {
    fn get_packet_id() -> i32 {
        16
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::VehicleMove(VehicleMove {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&VehicleMove::get_packet_id(), &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32) -> ServerboundPacket {
        ServerboundPacket::VehicleMove(VehicleMove {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SteerBoat {
    right: bool,
    left: bool,
}

impl SteerBoat {
    fn get_packet_id() -> i32 {
        17
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::SteerBoat(SteerBoat {
            right: read_bool(r)?,
            left: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SteerBoat::get_packet_id(), &mut ret)?;
        write_bool(&self.right, &mut ret)?;
        write_bool(&self.left, &mut ret)?;

        Ok(ret)
    }
    pub fn new(right: bool, left: bool) -> ServerboundPacket {
        ServerboundPacket::SteerBoat(SteerBoat {
            right: right,
            left: left,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerAbilities {
    flags: u8,
    flying_speed: f32,
    walking_speed: f32,
}

impl PlayerAbilities {
    fn get_packet_id() -> i32 {
        18
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerAbilities(PlayerAbilities {
            flags: read_u8(r)?,
            flying_speed: read_f32(r)?,
            walking_speed: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerAbilities::get_packet_id(), &mut ret)?;
        write_u8(&self.flags, &mut ret)?;
        write_f32(&self.flying_speed, &mut ret)?;
        write_f32(&self.walking_speed, &mut ret)?;

        Ok(ret)
    }
    pub fn new(flags: u8, flying_speed: f32, walking_speed: f32) -> ServerboundPacket {
        ServerboundPacket::PlayerAbilities(PlayerAbilities {
            flags: flags,
            flying_speed: flying_speed,
            walking_speed: walking_speed,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerDigging {
    status: i32,
    location: (i32, i32, i32),
    face: u8,
}

impl PlayerDigging {
    fn get_packet_id() -> i32 {
        19
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerDigging(PlayerDigging {
            status: read_varint(r)?,
            location: read_position(r)?,
            face: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerDigging::get_packet_id(), &mut ret)?;
        write_varint(&self.status, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_u8(&self.face, &mut ret)?;

        Ok(ret)
    }
    pub fn new(status: i32, location: (i32, i32, i32), face: u8) -> ServerboundPacket {
        ServerboundPacket::PlayerDigging(PlayerDigging {
            status: status,
            location: location,
            face: face,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityAction {
    entity_id: i32,
    action: i32,
    jump_boost: i32,
}

impl EntityAction {
    fn get_packet_id() -> i32 {
        20
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::EntityAction(EntityAction {
            entity_id: read_varint(r)?,
            action: read_varint(r)?,
            jump_boost: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityAction::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_varint(&self.action, &mut ret)?;
        write_varint(&self.jump_boost, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, action: i32, jump_boost: i32) -> ServerboundPacket {
        ServerboundPacket::EntityAction(EntityAction {
            entity_id: entity_id,
            action: action,
            jump_boost: jump_boost,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SteerVehicle {
    sideways: f32,
    forward: f32,
    flags: u8,
}

impl SteerVehicle {
    fn get_packet_id() -> i32 {
        21
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::SteerVehicle(SteerVehicle {
            sideways: read_f32(r)?,
            forward: read_f32(r)?,
            flags: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SteerVehicle::get_packet_id(), &mut ret)?;
        write_f32(&self.sideways, &mut ret)?;
        write_f32(&self.forward, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;

        Ok(ret)
    }
    pub fn new(sideways: f32, forward: f32, flags: u8) -> ServerboundPacket {
        ServerboundPacket::SteerVehicle(SteerVehicle {
            sideways: sideways,
            forward: forward,
            flags: flags,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ResourcePackStatus {
    result: i32,
}

impl ResourcePackStatus {
    fn get_packet_id() -> i32 {
        22
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::ResourcePackStatus(ResourcePackStatus {
            result: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ResourcePackStatus::get_packet_id(), &mut ret)?;
        write_varint(&self.result, &mut ret)?;

        Ok(ret)
    }
    pub fn new(result: i32) -> ServerboundPacket {
        ServerboundPacket::ResourcePackStatus(ResourcePackStatus {
            result: result,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct HeldItemChange {
    slot: i16,
}

impl HeldItemChange {
    fn get_packet_id() -> i32 {
        23
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::HeldItemChange(HeldItemChange {
            slot: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&HeldItemChange::get_packet_id(), &mut ret)?;
        write_i16(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot: i16) -> ServerboundPacket {
        ServerboundPacket::HeldItemChange(HeldItemChange {
            slot: slot,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct CreativeInventoryAction {
    slot_id: i16,
    slot: Vec<u8>,
}

impl CreativeInventoryAction {
    fn get_packet_id() -> i32 {
        24
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::CreativeInventoryAction(CreativeInventoryAction {
            slot_id: read_i16(r)?,
            slot: read_bytearray(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&CreativeInventoryAction::get_packet_id(), &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_bytearray(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot_id: i16, slot: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::CreativeInventoryAction(CreativeInventoryAction {
            slot_id: slot_id,
            slot: slot,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateSign {
    location: (i32, i32, i32),
    line1: String,
    line2: String,
    line3: String,
    line4: String,
}

impl UpdateSign {
    fn get_packet_id() -> i32 {
        25
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::UpdateSign(UpdateSign {
            location: read_position(r)?,
            line1: read_String(r)?,
            line2: read_String(r)?,
            line3: read_String(r)?,
            line4: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&UpdateSign::get_packet_id(), &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_String(&self.line1, &mut ret)?;
        write_String(&self.line2, &mut ret)?;
        write_String(&self.line3, &mut ret)?;
        write_String(&self.line4, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), line1: String, line2: String, line3: String, line4: String) -> ServerboundPacket {
        ServerboundPacket::UpdateSign(UpdateSign {
            location: location,
            line1: line1,
            line2: line2,
            line3: line3,
            line4: line4,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Animation {
    hand: i32,
}

impl Animation {
    fn get_packet_id() -> i32 {
        26
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::Animation(Animation {
            hand: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Animation::get_packet_id(), &mut ret)?;
        write_varint(&self.hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(hand: i32) -> ServerboundPacket {
        ServerboundPacket::Animation(Animation {
            hand: hand,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Spectate {
    target: u128,
}

impl Spectate {
    fn get_packet_id() -> i32 {
        27
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::Spectate(Spectate {
            target: read_uuid(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Spectate::get_packet_id(), &mut ret)?;
        write_uuid(&self.target, &mut ret)?;

        Ok(ret)
    }
    pub fn new(target: u128) -> ServerboundPacket {
        ServerboundPacket::Spectate(Spectate {
            target: target,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerBlockPlacement {
    location: (i32, i32, i32),
    face: i32,
    hand: i32,
    x: f32,
    y: f32,
    z: f32,
}

impl PlayerBlockPlacement {
    fn get_packet_id() -> i32 {
        28
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerBlockPlacement(PlayerBlockPlacement {
            location: read_position(r)?,
            face: read_varint(r)?,
            hand: read_varint(r)?,
            x: read_f32(r)?,
            y: read_f32(r)?,
            z: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerBlockPlacement::get_packet_id(), &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_varint(&self.face, &mut ret)?;
        write_varint(&self.hand, &mut ret)?;
        write_f32(&self.x, &mut ret)?;
        write_f32(&self.y, &mut ret)?;
        write_f32(&self.z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), face: i32, hand: i32, x: f32, y: f32, z: f32) -> ServerboundPacket {
        ServerboundPacket::PlayerBlockPlacement(PlayerBlockPlacement {
            location: location,
            face: face,
            hand: hand,
            x: x,
            y: y,
            z: z,
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct UseItem {
    hand: i32,
}

impl UseItem {
    fn get_packet_id() -> i32 {
        29
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ServerboundPacket> {
        Ok(ServerboundPacket::UseItem(UseItem {
            hand: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&UseItem::get_packet_id(), &mut ret)?;
        write_varint(&self.hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(hand: i32) -> ServerboundPacket {
        ServerboundPacket::UseItem(UseItem {
            hand: hand,
        })
    }

}

