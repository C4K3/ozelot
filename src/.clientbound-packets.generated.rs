/* This file is automatically generated by packets.clj
Do not manually edit this file, if you wish to make
changes here, then edit and rerun packets.clj */

#[derive(Debug, PartialEq, Clone)]
pub struct StatusResponse {
    json: String,
}

impl StatusResponse {
    const PACKET_ID: i32 = 0;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::StatusResponse(StatusResponse {
            json: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.json, &mut ret)?;

        Ok(ret)
    }
    pub fn new(json: String) -> ClientboundPacket {
        ClientboundPacket::StatusResponse(StatusResponse {
            json: json,
        })
    }
    /// Get the raw json response
    pub fn get_json(&self) -> &String {
        &self.json
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusPong {
    id: u64,
}

impl StatusPong {
    const PACKET_ID: i32 = 1;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::StatusPong(StatusPong {
            id: read_u64(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: u64) -> ClientboundPacket {
        ClientboundPacket::StatusPong(StatusPong {
            id: id,
        })
    }
    /// Get the id of the ping/pong
    pub fn get_id(&self) -> &u64 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginDisconnect {
    raw_chat: String,
}

impl LoginDisconnect {
    const PACKET_ID: i32 = 0;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::LoginDisconnect(LoginDisconnect {
            raw_chat: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.raw_chat, &mut ret)?;

        Ok(ret)
    }
    pub fn new(raw_chat: String) -> ClientboundPacket {
        ClientboundPacket::LoginDisconnect(LoginDisconnect {
            raw_chat: raw_chat,
        })
    }
    /// Get the raw chat json
    pub fn get_raw_chat(&self) -> &String {
        &self.raw_chat
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EncryptionRequest {
    server_id: String,
    public_key: Vec<u8>,
    verify_token: Vec<u8>,
}

impl EncryptionRequest {
    const PACKET_ID: i32 = 1;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EncryptionRequest(EncryptionRequest {
            server_id: read_String(r)?,
            public_key: read_prefixed_bytearray(r)?,
            verify_token: read_prefixed_bytearray(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.server_id, &mut ret)?;
        write_prefixed_bytearray(&self.public_key, &mut ret)?;
        write_prefixed_bytearray(&self.verify_token, &mut ret)?;

        Ok(ret)
    }
    pub fn new(server_id: String, public_key: Vec<u8>, verify_token: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EncryptionRequest(EncryptionRequest {
            server_id: server_id,
            public_key: public_key,
            verify_token: verify_token,
        })
    }
    /// Get the server id
    pub fn get_server_id(&self) -> &String {
        &self.server_id
    }    /// Get the public key
    pub fn get_public_key(&self) -> &Vec<u8> {
        &self.public_key
    }    /// Get the verify token
    pub fn get_verify_token(&self) -> &Vec<u8> {
        &self.verify_token
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginSuccess {
    uuid: u128,
    username: String,
}

impl LoginSuccess {
    const PACKET_ID: i32 = 2;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::LoginSuccess(LoginSuccess {
            uuid: read_uuid_str(r)?,
            username: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_uuid_str(&self.uuid, &mut ret)?;
        write_String(&self.username, &mut ret)?;

        Ok(ret)
    }
    pub fn new(uuid: u128, username: String) -> ClientboundPacket {
        ClientboundPacket::LoginSuccess(LoginSuccess {
            uuid: uuid,
            username: username,
        })
    }
    /// Get the player's uuid
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the player's name
    pub fn get_username(&self) -> &String {
        &self.username
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetCompression {
    threshold: i32,
}

impl SetCompression {
    const PACKET_ID: i32 = 3;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetCompression(SetCompression {
            threshold: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.threshold, &mut ret)?;

        Ok(ret)
    }
    pub fn new(threshold: i32) -> ClientboundPacket {
        ClientboundPacket::SetCompression(SetCompression {
            threshold: threshold,
        })
    }
    /// Get the compression threshold
    pub fn get_threshold(&self) -> &i32 {
        &self.threshold
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnObject {
    entity_id: i32,
    object_uuid: u128,
    object_type: u8,
    x: f64,
    y: f64,
    z: f64,
    pitch: i8,
    yaw: i8,
    data: i32,
    velocity_x: i16,
    velocity_y: i16,
    velocity_z: i16,
}

impl SpawnObject {
    const PACKET_ID: i32 = 0;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnObject(SpawnObject {
            entity_id: read_varint(r)?,
            object_uuid: read_uuid(r)?,
            object_type: read_u8(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            pitch: read_i8(r)?,
            yaw: read_i8(r)?,
            data: read_i32(r)?,
            velocity_x: read_i16(r)?,
            velocity_y: read_i16(r)?,
            velocity_z: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.object_uuid, &mut ret)?;
        write_u8(&self.object_type, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i32(&self.data, &mut ret)?;
        write_i16(&self.velocity_x, &mut ret)?;
        write_i16(&self.velocity_y, &mut ret)?;
        write_i16(&self.velocity_z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, object_uuid: u128, object_type: u8, x: f64, y: f64, z: f64, pitch: i8, yaw: i8, data: i32, velocity_x: i16, velocity_y: i16, velocity_z: i16) -> ClientboundPacket {
        ClientboundPacket::SpawnObject(SpawnObject {
            entity_id: entity_id,
            object_uuid: object_uuid,
            object_type: object_type,
            x: x,
            y: y,
            z: z,
            pitch: pitch,
            yaw: yaw,
            data: data,
            velocity_x: velocity_x,
            velocity_y: velocity_y,
            velocity_z: velocity_z,
        })
    }
    /// Get the ID of the created object
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the created object
    pub fn get_object_uuid(&self) -> &u128 {
        &self.object_uuid
    }    /// get the object_type field (UNDOCUMENTED)
    pub fn get_object_type(&self) -> &u8 {
        &self.object_type
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// get the data field (UNDOCUMENTED)
    pub fn get_data(&self) -> &i32 {
        &self.data
    }    /// Get the X velocity
    pub fn get_velocity_x(&self) -> &i16 {
        &self.velocity_x
    }    /// Get the Y velocity
    pub fn get_velocity_y(&self) -> &i16 {
        &self.velocity_y
    }    /// Get the Z velocity
    pub fn get_velocity_z(&self) -> &i16 {
        &self.velocity_z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnExperienceOrb {
    entity_id: i32,
    x: f64,
    y: f64,
    z: f64,
    count: i16,
}

impl SpawnExperienceOrb {
    const PACKET_ID: i32 = 1;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnExperienceOrb(SpawnExperienceOrb {
            entity_id: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            count: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i16(&self.count, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: f64, y: f64, z: f64, count: i16) -> ClientboundPacket {
        ClientboundPacket::SpawnExperienceOrb(SpawnExperienceOrb {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            count: count,
        })
    }
    /// Get the ID of the orb
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the amount of experience this orb will reward
    pub fn get_count(&self) -> &i16 {
        &self.count
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnGlobalEntity {
    entity_id: i32,
    entity_type: u8,
    x: f64,
    y: f64,
    z: f64,
}

impl SpawnGlobalEntity {
    const PACKET_ID: i32 = 2;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnGlobalEntity(SpawnGlobalEntity {
            entity_id: read_varint(r)?,
            entity_type: read_u8(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.entity_type, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, entity_type: u8, x: f64, y: f64, z: f64) -> ClientboundPacket {
        ClientboundPacket::SpawnGlobalEntity(SpawnGlobalEntity {
            entity_id: entity_id,
            entity_type: entity_type,
            x: x,
            y: y,
            z: z,
        })
    }
    /// Get the ID of the entity
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// get the entity_type field (UNDOCUMENTED)
    pub fn get_entity_type(&self) -> &u8 {
        &self.entity_type
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnMob {
    entity_id: i32,
    uuid: u128,
    mob_type: i32,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    head_pitch: i8,
    velocity_x: i16,
    velocity_y: i16,
    velocity_z: i16,
    metadata: Vec<u8>,
}

impl SpawnMob {
    const PACKET_ID: i32 = 3;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnMob(SpawnMob {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            mob_type: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            head_pitch: read_i8(r)?,
            velocity_x: read_i16(r)?,
            velocity_y: read_i16(r)?,
            velocity_z: read_i16(r)?,
            metadata: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.uuid, &mut ret)?;
        write_varint(&self.mob_type, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_i8(&self.head_pitch, &mut ret)?;
        write_i16(&self.velocity_x, &mut ret)?;
        write_i16(&self.velocity_y, &mut ret)?;
        write_i16(&self.velocity_z, &mut ret)?;
        write_bytearray_to_end(&self.metadata, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, uuid: u128, mob_type: i32, x: f64, y: f64, z: f64, yaw: i8, pitch: i8, head_pitch: i8, velocity_x: i16, velocity_y: i16, velocity_z: i16, metadata: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::SpawnMob(SpawnMob {
            entity_id: entity_id,
            uuid: uuid,
            mob_type: mob_type,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            head_pitch: head_pitch,
            velocity_x: velocity_x,
            velocity_y: velocity_y,
            velocity_z: velocity_z,
            metadata: metadata,
        })
    }
    /// Get the ID of the mob
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the mob
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the type ID of the mob
    pub fn get_mob_type(&self) -> &i32 {
        &self.mob_type
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw of the mob
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the pitch of the mob
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get the pitch of the head of the mob
    pub fn get_head_pitch(&self) -> &i8 {
        &self.head_pitch
    }    /// Get the X velocity
    pub fn get_velocity_x(&self) -> &i16 {
        &self.velocity_x
    }    /// Get the Y velocity
    pub fn get_velocity_y(&self) -> &i16 {
        &self.velocity_y
    }    /// Get the Z velocity
    pub fn get_velocity_z(&self) -> &i16 {
        &self.velocity_z
    }    /// Get the raw metadata field. This library does not currently attempt to parse this field
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPainting {
    entity_id: i32,
    uuid: u128,
    title: String,
    center_location: (i32, i32, i32),
    direction: u8,
}

impl SpawnPainting {
    const PACKET_ID: i32 = 4;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPainting(SpawnPainting {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            title: read_String(r)?,
            center_location: read_position(r)?,
            direction: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.uuid, &mut ret)?;
        write_String(&self.title, &mut ret)?;
        write_position(&self.center_location, &mut ret)?;
        write_u8(&self.direction, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, uuid: u128, title: String, center_location: (i32, i32, i32), direction: u8) -> ClientboundPacket {
        ClientboundPacket::SpawnPainting(SpawnPainting {
            entity_id: entity_id,
            uuid: uuid,
            title: title,
            center_location: center_location,
            direction: direction,
        })
    }
    /// Get the entity ID of the painting
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the painting
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the title of the painting
    pub fn get_title(&self) -> &String {
        &self.title
    }    /// get the center_location field (UNDOCUMENTED)
    pub fn get_center_location(&self) -> &(i32, i32, i32) {
        &self.center_location
    }    /// The direction in which the painting faces
    pub fn get_direction(&self) -> &u8 {
        &self.direction
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPlayer {
    entity_id: i32,
    uuid: u128,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    metadata: Vec<u8>,
}

impl SpawnPlayer {
    const PACKET_ID: i32 = 5;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPlayer(SpawnPlayer {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            metadata: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.uuid, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bytearray_to_end(&self.metadata, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, uuid: u128, x: f64, y: f64, z: f64, yaw: i8, pitch: i8, metadata: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::SpawnPlayer(SpawnPlayer {
            entity_id: entity_id,
            uuid: uuid,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            metadata: metadata,
        })
    }
    /// Get the entity ID of the player
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the player
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get the raw metadata in the packet, this library does not attempt to parse this field
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundAnimation {
    entity_id: i32,
    animation: u8,
}

impl ClientboundAnimation {
    const PACKET_ID: i32 = 6;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundAnimation(ClientboundAnimation {
            entity_id: read_varint(r)?,
            animation: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.animation, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, animation: u8) -> ClientboundPacket {
        ClientboundPacket::ClientboundAnimation(ClientboundAnimation {
            entity_id: entity_id,
            animation: animation,
        })
    }
    /// Get the entity ID doing the animation
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the byte ID for what kind of animation it is
    pub fn get_animation(&self) -> &u8 {
        &self.animation
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Statistics {
    values: BTreeMap<String, i32>,
}

impl Statistics {
    const PACKET_ID: i32 = 7;


    pub fn new_raw(values: BTreeMap<String, i32>) -> ClientboundPacket {
        ClientboundPacket::Statistics(Statistics {
            values: values,
        })
    }
    /// Get the statistics, with the key being the name of the statistic and the value being the value.
    pub fn get_values(&self) -> &BTreeMap<String, i32> {
        &self.values
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockBreakAnimation {
    entity_id: i32,
}

impl BlockBreakAnimation {
    const PACKET_ID: i32 = 8;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockBreakAnimation(BlockBreakAnimation {
            entity_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::BlockBreakAnimation(BlockBreakAnimation {
            entity_id: entity_id,
        })
    }
    /// Get the entity ID doing the animation
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateBlockEntity {
    position: (i32, i32, i32),
    action: u8,
    nbt: Vec<u8>,
}

impl UpdateBlockEntity {
    const PACKET_ID: i32 = 9;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::UpdateBlockEntity(UpdateBlockEntity {
            position: read_position(r)?,
            action: read_u8(r)?,
            nbt: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.position, &mut ret)?;
        write_u8(&self.action, &mut ret)?;
        write_bytearray_to_end(&self.nbt, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32), action: u8, nbt: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::UpdateBlockEntity(UpdateBlockEntity {
            position: position,
            action: action,
            nbt: nbt,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }    /// Get the action ID being performed
    pub fn get_action(&self) -> &u8 {
        &self.action
    }    /// Get the raw NBT bytes
    pub fn get_nbt(&self) -> &Vec<u8> {
        &self.nbt
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockAction {
    position: (i32, i32, i32),
    action_id: u8,
    action_param: u8,
    block_type: i32,
}

impl BlockAction {
    const PACKET_ID: i32 = 10;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockAction(BlockAction {
            position: read_position(r)?,
            action_id: read_u8(r)?,
            action_param: read_u8(r)?,
            block_type: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.position, &mut ret)?;
        write_u8(&self.action_id, &mut ret)?;
        write_u8(&self.action_param, &mut ret)?;
        write_varint(&self.block_type, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32), action_id: u8, action_param: u8, block_type: i32) -> ClientboundPacket {
        ClientboundPacket::BlockAction(BlockAction {
            position: position,
            action_id: action_id,
            action_param: action_param,
            block_type: block_type,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }    /// Get the action ID
    pub fn get_action_id(&self) -> &u8 {
        &self.action_id
    }    /// Get the action parameter
    pub fn get_action_param(&self) -> &u8 {
        &self.action_param
    }    /// Get the block type
    pub fn get_block_type(&self) -> &i32 {
        &self.block_type
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockChange {
    position: (i32, i32, i32),
    new_block: i32,
}

impl BlockChange {
    const PACKET_ID: i32 = 11;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockChange(BlockChange {
            position: read_position(r)?,
            new_block: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.position, &mut ret)?;
        write_varint(&self.new_block, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32), new_block: i32) -> ClientboundPacket {
        ClientboundPacket::BlockChange(BlockChange {
            position: position,
            new_block: new_block,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }    /// Get the new block state ID for the block
    pub fn get_new_block(&self) -> &i32 {
        &self.new_block
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BossBar {
    data: Vec<u8>,
}

impl BossBar {
    const PACKET_ID: i32 = 12;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::BossBar(BossBar {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::BossBar(BossBar {
            data: data,
        })
    }
    /// Get the raw data from this packet. Parsing this is very dependent on the specific client, and doing so would be out of scope for this library, therefore parsing this packet is left to the user of the library.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ServerDifficulty {
    difficulty: u8,
}

impl ServerDifficulty {
    const PACKET_ID: i32 = 13;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ServerDifficulty(ServerDifficulty {
            difficulty: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.difficulty, &mut ret)?;

        Ok(ret)
    }
    pub fn new(difficulty: u8) -> ClientboundPacket {
        ClientboundPacket::ServerDifficulty(ServerDifficulty {
            difficulty: difficulty,
        })
    }
    /// Get the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundTabComplete {
    matches: Vec<String>,
}

impl ClientboundTabComplete {
    const PACKET_ID: i32 = 14;


    pub fn new_raw(matches: Vec<String>) -> ClientboundPacket {
        ClientboundPacket::ClientboundTabComplete(ClientboundTabComplete {
            matches: matches,
        })
    }
    /// Get the matches
    pub fn get_matches(&self) -> &Vec<String> {
        &self.matches
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChatMessage {
    chat: String,
    position: u8,
}

impl ChatMessage {
    const PACKET_ID: i32 = 15;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChatMessage(ChatMessage {
            chat: read_String(r)?,
            position: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.chat, &mut ret)?;
        write_u8(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(chat: String, position: u8) -> ClientboundPacket {
        ClientboundPacket::ChatMessage(ChatMessage {
            chat: chat,
            position: position,
        })
    }
    /// Get the raw JSON data of the chat message
    pub fn get_chat(&self) -> &String {
        &self.chat
    }    /// Get the position of the chat message
    pub fn get_position(&self) -> &u8 {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct MultiBlockChange {
    chunk_x: i32,
    chunk_z: i32,
    changes: Vec<(u8, u8, u8, i32)>,
}

impl MultiBlockChange {
    const PACKET_ID: i32 = 16;


    pub fn new_raw(chunk_x: i32, chunk_z: i32, changes: Vec<(u8, u8, u8, i32)>) -> ClientboundPacket {
        ClientboundPacket::MultiBlockChange(MultiBlockChange {
            chunk_x: chunk_x,
            chunk_z: chunk_z,
            changes: changes,
        })
    }
    /// Get the chunk X coordinate
    pub fn get_chunk_x(&self) -> &i32 {
        &self.chunk_x
    }    /// Get the chunk Z coordinate
    pub fn get_chunk_z(&self) -> &i32 {
        &self.chunk_z
    }    /// Get the changes as a vector, in the form of Vec<(x, y, z, new_block_state)>, where the x, y, z are relative to the chunk.
    pub fn get_changes(&self) -> &Vec<(u8, u8, u8, i32)> {
        &self.changes
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundConfirmTransaction {
    window_id: u8,
    action_id: i16,
    accepted: bool,
}

impl ClientboundConfirmTransaction {
    const PACKET_ID: i32 = 17;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundConfirmTransaction(ClientboundConfirmTransaction {
            window_id: read_u8(r)?,
            action_id: read_i16(r)?,
            accepted: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.action_id, &mut ret)?;
        write_bool(&self.accepted, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, action_id: i16, accepted: bool) -> ClientboundPacket {
        ClientboundPacket::ClientboundConfirmTransaction(ClientboundConfirmTransaction {
            window_id: window_id,
            action_id: action_id,
            accepted: accepted,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the action ID (nonce)
    pub fn get_action_id(&self) -> &i16 {
        &self.action_id
    }    /// get the accepted field (UNDOCUMENTED)
    pub fn get_accepted(&self) -> &bool {
        &self.accepted
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundCloseWindow {
    window_id: u8,
}

impl ClientboundCloseWindow {
    const PACKET_ID: i32 = 18;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundCloseWindow(ClientboundCloseWindow {
            window_id: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8) -> ClientboundPacket {
        ClientboundPacket::ClientboundCloseWindow(ClientboundCloseWindow {
            window_id: window_id,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct OpenWindow {
    window_id: u8,
    window_type: String,
    window_title: String,
    number_of_slots: u8,
    entity_id: Option<i32>,
}

impl OpenWindow {
    const PACKET_ID: i32 = 19;


    pub fn new_raw(window_id: u8, window_type: String, window_title: String, number_of_slots: u8, entity_id: Option<i32>) -> ClientboundPacket {
        ClientboundPacket::OpenWindow(OpenWindow {
            window_id: window_id,
            window_type: window_type,
            window_title: window_title,
            number_of_slots: number_of_slots,
            entity_id: entity_id,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the window type
    pub fn get_window_type(&self) -> &String {
        &self.window_type
    }    /// Get the raw JSON of the window title
    pub fn get_window_title(&self) -> &String {
        &self.window_title
    }    /// Get the number of slots in the window
    pub fn get_number_of_slots(&self) -> &u8 {
        &self.number_of_slots
    }    /// Get the entity ID if the window type is `EntityHorse`, else `None`
    pub fn get_entity_id(&self) -> &Option<i32> {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct WindowItems {
    window_id: u8,
    slots: Vec<u8>,
}

impl WindowItems {
    const PACKET_ID: i32 = 20;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::WindowItems(WindowItems {
            window_id: read_u8(r)?,
            slots: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_bytearray_to_end(&self.slots, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, slots: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::WindowItems(WindowItems {
            window_id: window_id,
            slots: slots,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the remaining slot data, that is the last two fields described at http://wiki.vg/Protocol#Window_Items
    pub fn get_slots(&self) -> &Vec<u8> {
        &self.slots
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct WindowProperty {
    window_id: u8,
    property: i16,
    new_value: i16,
}

impl WindowProperty {
    const PACKET_ID: i32 = 21;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::WindowProperty(WindowProperty {
            window_id: read_u8(r)?,
            property: read_i16(r)?,
            new_value: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.property, &mut ret)?;
        write_i16(&self.new_value, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, property: i16, new_value: i16) -> ClientboundPacket {
        ClientboundPacket::WindowProperty(WindowProperty {
            window_id: window_id,
            property: property,
            new_value: new_value,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the property being updated
    pub fn get_property(&self) -> &i16 {
        &self.property
    }    /// Get the new value of the propery
    pub fn get_new_value(&self) -> &i16 {
        &self.new_value
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetSlot {
    window_id: u8,
    slot_id: i16,
    slot_data: Vec<u8>,
}

impl SetSlot {
    const PACKET_ID: i32 = 22;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetSlot(SetSlot {
            window_id: read_u8(r)?,
            slot_id: read_i16(r)?,
            slot_data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_bytearray_to_end(&self.slot_data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, slot_id: i16, slot_data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::SetSlot(SetSlot {
            window_id: window_id,
            slot_id: slot_id,
            slot_data: slot_data,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the ID of the slot to be updated
    pub fn get_slot_id(&self) -> &i16 {
        &self.slot_id
    }    /// Get the slot data of the packet in raw, unprocessed format
    pub fn get_slot_data(&self) -> &Vec<u8> {
        &self.slot_data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetCooldown {
    item_id: i32,
    cooldown: i32,
}

impl SetCooldown {
    const PACKET_ID: i32 = 23;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetCooldown(SetCooldown {
            item_id: read_varint(r)?,
            cooldown: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.item_id, &mut ret)?;
        write_varint(&self.cooldown, &mut ret)?;

        Ok(ret)
    }
    pub fn new(item_id: i32, cooldown: i32) -> ClientboundPacket {
        ClientboundPacket::SetCooldown(SetCooldown {
            item_id: item_id,
            cooldown: cooldown,
        })
    }
    /// Get the ID of the item the cool applied to
    pub fn get_item_id(&self) -> &i32 {
        &self.item_id
    }    /// Get the cooldown on the item specified in ticks
    pub fn get_cooldown(&self) -> &i32 {
        &self.cooldown
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundPluginMessage {
    channel: String,
    data: Vec<u8>,
}

impl ClientboundPluginMessage {
    const PACKET_ID: i32 = 24;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundPluginMessage(ClientboundPluginMessage {
            channel: read_String(r)?,
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.channel, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(channel: String, data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::ClientboundPluginMessage(ClientboundPluginMessage {
            channel: channel,
            data: data,
        })
    }
    /// Get the channel
    pub fn get_channel(&self) -> &String {
        &self.channel
    }    /// Get the raw data
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct NamedSoundEffect {
    sound_name: String,
    sound_category: i32,
    x: i32,
    y: i32,
    z: i32,
    volume: f32,
    pitch: f32,
}

impl NamedSoundEffect {
    const PACKET_ID: i32 = 25;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::NamedSoundEffect(NamedSoundEffect {
            sound_name: read_String(r)?,
            sound_category: read_varint(r)?,
            x: read_i32(r)?,
            y: read_i32(r)?,
            z: read_i32(r)?,
            volume: read_f32(r)?,
            pitch: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.sound_name, &mut ret)?;
        write_varint(&self.sound_category, &mut ret)?;
        write_i32(&self.x, &mut ret)?;
        write_i32(&self.y, &mut ret)?;
        write_i32(&self.z, &mut ret)?;
        write_f32(&self.volume, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(sound_name: String, sound_category: i32, x: i32, y: i32, z: i32, volume: f32, pitch: f32) -> ClientboundPacket {
        ClientboundPacket::NamedSoundEffect(NamedSoundEffect {
            sound_name: sound_name,
            sound_category: sound_category,
            x: x,
            y: y,
            z: z,
            volume: volume,
            pitch: pitch,
        })
    }
    /// Get the name of the sound
    pub fn get_sound_name(&self) -> &String {
        &self.sound_name
    }    /// Get the category of the sound
    pub fn get_sound_category(&self) -> &i32 {
        &self.sound_category
    }    /// Get the X coordinate multiplied by 8
    pub fn get_x(&self) -> &i32 {
        &self.x
    }    /// Get the Y coordinate multiplied by 8
    pub fn get_y(&self) -> &i32 {
        &self.y
    }    /// Get the Z coordinate multiplied by 8
    pub fn get_z(&self) -> &i32 {
        &self.z
    }    /// Get the volume
    pub fn get_volume(&self) -> &f32 {
        &self.volume
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayDisconnect {
    reason: String,
}

impl PlayDisconnect {
    const PACKET_ID: i32 = 26;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayDisconnect(PlayDisconnect {
            reason: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.reason, &mut ret)?;

        Ok(ret)
    }
    pub fn new(reason: String) -> ClientboundPacket {
        ClientboundPacket::PlayDisconnect(PlayDisconnect {
            reason: reason,
        })
    }
    /// Get the reason in raw json format
    pub fn get_reason(&self) -> &String {
        &self.reason
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityStatus {
    entity_id: i32,
    status: u8,
}

impl EntityStatus {
    const PACKET_ID: i32 = 27;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityStatus(EntityStatus {
            entity_id: read_i32(r)?,
            status: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i32(&self.entity_id, &mut ret)?;
        write_u8(&self.status, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, status: u8) -> ClientboundPacket {
        ClientboundPacket::EntityStatus(EntityStatus {
            entity_id: entity_id,
            status: status,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the status of the entity
    pub fn get_status(&self) -> &u8 {
        &self.status
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Explosion {
    x: f32,
    y: f32,
    z: f32,
    radius: f32,
    affected_blocks: Vec<(i8, i8, i8)>,
    motion_x: f32,
    motion_y: f32,
    motion_z: f32,
}

impl Explosion {
    const PACKET_ID: i32 = 28;


    pub fn new_raw(x: f32, y: f32, z: f32, radius: f32, affected_blocks: Vec<(i8, i8, i8)>, motion_x: f32, motion_y: f32, motion_z: f32) -> ClientboundPacket {
        ClientboundPacket::Explosion(Explosion {
            x: x,
            y: y,
            z: z,
            radius: radius,
            affected_blocks: affected_blocks,
            motion_x: motion_x,
            motion_y: motion_y,
            motion_z: motion_z,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f32 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f32 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f32 {
        &self.z
    }    /// Get the radius
    pub fn get_radius(&self) -> &f32 {
        &self.radius
    }    /// A list of the blocks affected by the explosion, given in Vec<(x, y, z)> where x, y, z are offsets from the explosions center
    pub fn get_affected_blocks(&self) -> &Vec<(i8, i8, i8)> {
        &self.affected_blocks
    }    /// Get the motion in the X direction that the player suffers as a result of the explosion
    pub fn get_motion_x(&self) -> &f32 {
        &self.motion_x
    }    /// Get the motion in the Y direction that the player suffers as a result of the explosion
    pub fn get_motion_y(&self) -> &f32 {
        &self.motion_y
    }    /// Get the motion in the Z direction that the player suffers as a result of the explosion
    pub fn get_motion_z(&self) -> &f32 {
        &self.motion_z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UnloadChunk {
    chunk_x: i32,
    chunk_z: i32,
}

impl UnloadChunk {
    const PACKET_ID: i32 = 29;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::UnloadChunk(UnloadChunk {
            chunk_x: read_i32(r)?,
            chunk_z: read_i32(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i32(&self.chunk_x, &mut ret)?;
        write_i32(&self.chunk_z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(chunk_x: i32, chunk_z: i32) -> ClientboundPacket {
        ClientboundPacket::UnloadChunk(UnloadChunk {
            chunk_x: chunk_x,
            chunk_z: chunk_z,
        })
    }
    /// Get the chunk's X coordinate
    pub fn get_chunk_x(&self) -> &i32 {
        &self.chunk_x
    }    /// Get the chunk's Z coordinate
    pub fn get_chunk_z(&self) -> &i32 {
        &self.chunk_z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChangeGameState {
    action: u8,
    value: f32,
}

impl ChangeGameState {
    const PACKET_ID: i32 = 30;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChangeGameState(ChangeGameState {
            action: read_u8(r)?,
            value: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.action, &mut ret)?;
        write_f32(&self.value, &mut ret)?;

        Ok(ret)
    }
    pub fn new(action: u8, value: f32) -> ClientboundPacket {
        ClientboundPacket::ChangeGameState(ChangeGameState {
            action: action,
            value: value,
        })
    }
    /// Get the reason for the change as a byte
    pub fn get_action(&self) -> &u8 {
        &self.action
    }    /// Get the value, its meaning depends on the action
    pub fn get_value(&self) -> &f32 {
        &self.value
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct KeepAlive {
    id: i64,
}

impl KeepAlive {
    const PACKET_ID: i32 = 31;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::KeepAlive(KeepAlive {
            id: read_i64(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i64) -> ClientboundPacket {
        ClientboundPacket::KeepAlive(KeepAlive {
            id: id,
        })
    }
    /// Get the ID of the keep alive packet
    pub fn get_id(&self) -> &i64 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChunkData {
    data: Vec<u8>,
}

impl ChunkData {
    const PACKET_ID: i32 = 32;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChunkData(ChunkData {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::ChunkData(ChunkData {
            data: data,
        })
    }
    /// Get all the data contained in this packet. Currently it's decided that this library shouldn't try to interpret complex data structures that are likely dependent on the specific implementation, so the parsing of this packet is left up to the client.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Effect {
    effect_id: i32,
    location: (i32, i32, i32),
    data: i32,
    disable_relative_volume: bool,
}

impl Effect {
    const PACKET_ID: i32 = 33;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::Effect(Effect {
            effect_id: read_i32(r)?,
            location: read_position(r)?,
            data: read_i32(r)?,
            disable_relative_volume: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i32(&self.effect_id, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_i32(&self.data, &mut ret)?;
        write_bool(&self.disable_relative_volume, &mut ret)?;

        Ok(ret)
    }
    pub fn new(effect_id: i32, location: (i32, i32, i32), data: i32, disable_relative_volume: bool) -> ClientboundPacket {
        ClientboundPacket::Effect(Effect {
            effect_id: effect_id,
            location: location,
            data: data,
            disable_relative_volume: disable_relative_volume,
        })
    }
    /// Get the ID of the effect
    pub fn get_effect_id(&self) -> &i32 {
        &self.effect_id
    }    /// get the location field (UNDOCUMENTED)
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the data for this effect
    pub fn get_data(&self) -> &i32 {
        &self.data
    }    /// Get whether to disable relative volume
    pub fn get_disable_relative_volume(&self) -> &bool {
        &self.disable_relative_volume
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Particle {
    particle_id: i32,
    use_long_distance: bool,
    x: f32,
    y: f32,
    z: f32,
    offset_x: f32,
    offset_y: f32,
    offset_z: f32,
    particle_data: f32,
    count: i32,
    id: Option<i32>,
    crack_data: Option<i32>,
}

impl Particle {
    const PACKET_ID: i32 = 34;


    pub fn new_raw(particle_id: i32, use_long_distance: bool, x: f32, y: f32, z: f32, offset_x: f32, offset_y: f32, offset_z: f32, particle_data: f32, count: i32, id: Option<i32>, crack_data: Option<i32>) -> ClientboundPacket {
        ClientboundPacket::Particle(Particle {
            particle_id: particle_id,
            use_long_distance: use_long_distance,
            x: x,
            y: y,
            z: z,
            offset_x: offset_x,
            offset_y: offset_y,
            offset_z: offset_z,
            particle_data: particle_data,
            count: count,
            id: id,
            crack_data: crack_data,
        })
    }
    /// Get the particle ID
    pub fn get_particle_id(&self) -> &i32 {
        &self.particle_id
    }    /// Get whether to use long distance (65536) instead of short (256)
    pub fn get_use_long_distance(&self) -> &bool {
        &self.use_long_distance
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f32 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f32 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f32 {
        &self.z
    }    /// Get the X offset
    pub fn get_offset_x(&self) -> &f32 {
        &self.offset_x
    }    /// Get the Y offset
    pub fn get_offset_y(&self) -> &f32 {
        &self.offset_y
    }    /// Get the Z offset
    pub fn get_offset_z(&self) -> &f32 {
        &self.offset_z
    }    /// Get the particle data for each particle
    pub fn get_particle_data(&self) -> &f32 {
        &self.particle_data
    }    /// Get the amount of particles to create
    pub fn get_count(&self) -> &i32 {
        &self.count
    }    /// Get the id for iconcrack, blockcrack and blockdust
    pub fn get_id(&self) -> &Option<i32> {
        &self.id
    }    /// Get the data for iconcrack and blockcrack
    pub fn get_crack_data(&self) -> &Option<i32> {
        &self.crack_data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct JoinGame {
    entity_id: i32,
    gamemode: u8,
    dimension: i32,
    difficulty: u8,
    max_players: u8,
    level_type: String,
    reduced_debug: bool,
}

impl JoinGame {
    const PACKET_ID: i32 = 35;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::JoinGame(JoinGame {
            entity_id: read_i32(r)?,
            gamemode: read_u8(r)?,
            dimension: read_i32(r)?,
            difficulty: read_u8(r)?,
            max_players: read_u8(r)?,
            level_type: read_String(r)?,
            reduced_debug: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i32(&self.entity_id, &mut ret)?;
        write_u8(&self.gamemode, &mut ret)?;
        write_i32(&self.dimension, &mut ret)?;
        write_u8(&self.difficulty, &mut ret)?;
        write_u8(&self.max_players, &mut ret)?;
        write_String(&self.level_type, &mut ret)?;
        write_bool(&self.reduced_debug, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, gamemode: u8, dimension: i32, difficulty: u8, max_players: u8, level_type: String, reduced_debug: bool) -> ClientboundPacket {
        ClientboundPacket::JoinGame(JoinGame {
            entity_id: entity_id,
            gamemode: gamemode,
            dimension: dimension,
            difficulty: difficulty,
            max_players: max_players,
            level_type: level_type,
            reduced_debug: reduced_debug,
        })
    }
    /// Get the player's entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the player's gamemode
    pub fn get_gamemode(&self) -> &u8 {
        &self.gamemode
    }    /// Get the dimension the player is in. Not the specific world (in case of servers with multiworld), but the kind of world
    pub fn get_dimension(&self) -> &i32 {
        &self.dimension
    }    /// Get the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }    /// get the max_players field (UNDOCUMENTED)
    pub fn get_max_players(&self) -> &u8 {
        &self.max_players
    }    /// Get the level type of the world the player joined in
    pub fn get_level_type(&self) -> &String {
        &self.level_type
    }    /// Get whether to show reduced debug info
    pub fn get_reduced_debug(&self) -> &bool {
        &self.reduced_debug
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Map {
    data: Vec<u8>,
}

impl Map {
    const PACKET_ID: i32 = 36;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::Map(Map {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::Map(Map {
            data: data,
        })
    }
    /// Get the raw data from this packet. Parsing this is very dependent on the specific client, and doing so would be out of scope for this library, therefore parsing this packet is left to the user of the library.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Entity {
    entity_id: i32,
}

impl Entity {
    const PACKET_ID: i32 = 37;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::Entity(Entity {
            entity_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::Entity(Entity {
            entity_id: entity_id,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityRelativeMove {
    entity_id: i32,
    x: i16,
    y: i16,
    z: i16,
    on_ground: bool,
}

impl EntityRelativeMove {
    const PACKET_ID: i32 = 38;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityRelativeMove(EntityRelativeMove {
            entity_id: read_varint(r)?,
            x: read_i16(r)?,
            y: read_i16(r)?,
            z: read_i16(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i16(&self.x, &mut ret)?;
        write_i16(&self.y, &mut ret)?;
        write_i16(&self.z, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: i16, y: i16, z: i16, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityRelativeMove(EntityRelativeMove {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the relative distanced moved in the X direction times 128
    pub fn get_x(&self) -> &i16 {
        &self.x
    }    /// Get the relative distanced moved in the Y direction times 128
    pub fn get_y(&self) -> &i16 {
        &self.y
    }    /// Get the relative distanced moved in the Z direction times 128
    pub fn get_z(&self) -> &i16 {
        &self.z
    }    /// Get whether the entity is on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityLookRelativeMove {
    entity_id: i32,
    x: i16,
    y: i16,
    z: i16,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityLookRelativeMove {
    const PACKET_ID: i32 = 39;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityLookRelativeMove(EntityLookRelativeMove {
            entity_id: read_varint(r)?,
            x: read_i16(r)?,
            y: read_i16(r)?,
            z: read_i16(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i16(&self.x, &mut ret)?;
        write_i16(&self.y, &mut ret)?;
        write_i16(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: i16, y: i16, z: i16, yaw: i8, pitch: i8, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityLookRelativeMove(EntityLookRelativeMove {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the relative distanced moved in the X direction times 128
    pub fn get_x(&self) -> &i16 {
        &self.x
    }    /// Get the relative distanced moved in the Y direction times 128
    pub fn get_y(&self) -> &i16 {
        &self.y
    }    /// Get the relative distanced moved in the Z direction times 128
    pub fn get_z(&self) -> &i16 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get whether the entity is on the grouns
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityLook {
    entity_id: i32,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityLook {
    const PACKET_ID: i32 = 40;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityLook(EntityLook {
            entity_id: read_varint(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, yaw: i8, pitch: i8, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityLook(EntityLook {
            entity_id: entity_id,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the (absolute) angle
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundVehicleMove {
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
}

impl ClientboundVehicleMove {
    const PACKET_ID: i32 = 41;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundVehicleMove(ClientboundVehicleMove {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: i8, pitch: i8) -> ClientboundPacket {
        ClientboundPacket::ClientboundVehicleMove(ClientboundVehicleMove {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the (absolute) angle
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct OpenSignEditor {
    position: (i32, i32, i32),
}

impl OpenSignEditor {
    const PACKET_ID: i32 = 42;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::OpenSignEditor(OpenSignEditor {
            position: read_position(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32)) -> ClientboundPacket {
        ClientboundPacket::OpenSignEditor(OpenSignEditor {
            position: position,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CraftRecipeResponse {
    window_id: u8,
    recipe: i32,
}

impl CraftRecipeResponse {
    const PACKET_ID: i32 = 43;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::CraftRecipeResponse(CraftRecipeResponse {
            window_id: read_u8(r)?,
            recipe: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_varint(&self.recipe, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, recipe: i32) -> ClientboundPacket {
        ClientboundPacket::CraftRecipeResponse(CraftRecipeResponse {
            window_id: window_id,
            recipe: recipe,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the recipe ID
    pub fn get_recipe(&self) -> &i32 {
        &self.recipe
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerAbilities {
    flags: u8,
    flying_speed: f32,
    fov: f32,
}

impl PlayerAbilities {
    const PACKET_ID: i32 = 44;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerAbilities(PlayerAbilities {
            flags: read_u8(r)?,
            flying_speed: read_f32(r)?,
            fov: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;
        write_f32(&self.flying_speed, &mut ret)?;
        write_f32(&self.fov, &mut ret)?;

        Ok(ret)
    }
    pub fn new(flags: u8, flying_speed: f32, fov: f32) -> ClientboundPacket {
        ClientboundPacket::PlayerAbilities(PlayerAbilities {
            flags: flags,
            flying_speed: flying_speed,
            fov: fov,
        })
    }
    /// get the flags field (UNDOCUMENTED)
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }    /// Get the player's allowed flying speed
    pub fn get_flying_speed(&self) -> &f32 {
        &self.flying_speed
    }    /// Get the player's field of view modifier
    pub fn get_fov(&self) -> &f32 {
        &self.fov
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CombatEvent {
    event: i32,
    duration_playerid: Option<i32>,
    entity_id: Option<i32>,
    message: Option<String>,
}

impl CombatEvent {
    const PACKET_ID: i32 = 45;


    pub fn new_raw(event: i32, duration_playerid: Option<i32>, entity_id: Option<i32>, message: Option<String>) -> ClientboundPacket {
        ClientboundPacket::CombatEvent(CombatEvent {
            event: event,
            duration_playerid: duration_playerid,
            entity_id: entity_id,
            message: message,
        })
    }
    /// get the event field (UNDOCUMENTED)
    pub fn get_event(&self) -> &i32 {
        &self.event
    }    /// get the duration_playerid field (UNDOCUMENTED)
    pub fn get_duration_playerid(&self) -> &Option<i32> {
        &self.duration_playerid
    }    /// Get the entity ID if packet action is 'end combat' or 'entity dead'
    pub fn get_entity_id(&self) -> &Option<i32> {
        &self.entity_id
    }    /// get the message field (UNDOCUMENTED)
    pub fn get_message(&self) -> &Option<String> {
        &self.message
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerListItem {
    data: Vec<u8>,
}

impl PlayerListItem {
    const PACKET_ID: i32 = 46;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerListItem(PlayerListItem {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::PlayerListItem(PlayerListItem {
            data: data,
        })
    }
    /// Get the raw data from this packet. This library does not attempt to parse this packet.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPositionAndLook {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
    flags: u8,
    teleport_id: i32,
}

impl PlayerPositionAndLook {
    const PACKET_ID: i32 = 47;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,
            flags: read_u8(r)?,
            teleport_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;
        write_varint(&self.teleport_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32, flags: u8, teleport_id: i32) -> ClientboundPacket {
        ClientboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            flags: flags,
            teleport_id: teleport_id,
        })
    }
    /// Get the x coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }    /// Get the raw flags bitmask
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }    /// Get the teleport ID to be used in the serverbound TeleportConfirm packet.
    pub fn get_teleport_id(&self) -> &i32 {
        &self.teleport_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UseBed {
    entity_id: i32,
    position: (i32, i32, i32),
}

impl UseBed {
    const PACKET_ID: i32 = 48;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::UseBed(UseBed {
            entity_id: read_varint(r)?,
            position: read_position(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_position(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, position: (i32, i32, i32)) -> ClientboundPacket {
        ClientboundPacket::UseBed(UseBed {
            entity_id: entity_id,
            position: position,
        })
    }
    /// Get the entity ID of the player sleeping
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UnlockRecipes {
    action: i32,
    crafting_book_open: bool,
    filter_craftable: bool,
    recipes: Vec<i32>,
    recipes2: Vec<i32>,
}

impl UnlockRecipes {
    const PACKET_ID: i32 = 49;


    pub fn new_raw(action: i32, crafting_book_open: bool, filter_craftable: bool, recipes: Vec<i32>, recipes2: Vec<i32>) -> ClientboundPacket {
        ClientboundPacket::UnlockRecipes(UnlockRecipes {
            action: action,
            crafting_book_open: crafting_book_open,
            filter_craftable: filter_craftable,
            recipes: recipes,
            recipes2: recipes2,
        })
    }
    /// Get the action enum ID
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get whether the crafting book shall open when the player opens their inventory
    pub fn get_crafting_book_open(&self) -> &bool {
        &self.crafting_book_open
    }    /// Get whether to filter for only craftable items
    pub fn get_filter_craftable(&self) -> &bool {
        &self.filter_craftable
    }    /// Get all the recipes in list 1
    pub fn get_recipes(&self) -> &Vec<i32> {
        &self.recipes
    }    /// Get all the recipes in list 2. Is empty unless action == 0
    pub fn get_recipes2(&self) -> &Vec<i32> {
        &self.recipes2
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct DestroyEntities {
    entity_ids: Vec<i32>,
}

impl DestroyEntities {
    const PACKET_ID: i32 = 50;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::DestroyEntities(DestroyEntities {
            entity_ids: read_prefixed_varintarray(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_prefixed_varintarray(&self.entity_ids, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_ids: Vec<i32>) -> ClientboundPacket {
        ClientboundPacket::DestroyEntities(DestroyEntities {
            entity_ids: entity_ids,
        })
    }
    /// Get the list of entity IDs that have been destroyed
    pub fn get_entity_ids(&self) -> &Vec<i32> {
        &self.entity_ids
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct RemoveEntityEffect {
    entity_id: i32,
    effect_id: u8,
}

impl RemoveEntityEffect {
    const PACKET_ID: i32 = 51;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::RemoveEntityEffect(RemoveEntityEffect {
            entity_id: read_varint(r)?,
            effect_id: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.effect_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, effect_id: u8) -> ClientboundPacket {
        ClientboundPacket::RemoveEntityEffect(RemoveEntityEffect {
            entity_id: entity_id,
            effect_id: effect_id,
        })
    }
    /// Get the entity ID to remove the effect from
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// get the effect_id field (UNDOCUMENTED)
    pub fn get_effect_id(&self) -> &u8 {
        &self.effect_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ResourcePackSend {
    url: String,
    hash: String,
}

impl ResourcePackSend {
    const PACKET_ID: i32 = 52;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ResourcePackSend(ResourcePackSend {
            url: read_String(r)?,
            hash: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.url, &mut ret)?;
        write_String(&self.hash, &mut ret)?;

        Ok(ret)
    }
    pub fn new(url: String, hash: String) -> ClientboundPacket {
        ClientboundPacket::ResourcePackSend(ResourcePackSend {
            url: url,
            hash: hash,
        })
    }
    /// Get the URL to the resource pack
    pub fn get_url(&self) -> &String {
        &self.url
    }    /// Get the expected SHA-1 hash of the resource pack
    pub fn get_hash(&self) -> &String {
        &self.hash
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Respawn {
    dimension: i32,
    difficulty: u8,
    gamemode: u8,
    level_type: String,
}

impl Respawn {
    const PACKET_ID: i32 = 53;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::Respawn(Respawn {
            dimension: read_i32(r)?,
            difficulty: read_u8(r)?,
            gamemode: read_u8(r)?,
            level_type: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i32(&self.dimension, &mut ret)?;
        write_u8(&self.difficulty, &mut ret)?;
        write_u8(&self.gamemode, &mut ret)?;
        write_String(&self.level_type, &mut ret)?;

        Ok(ret)
    }
    pub fn new(dimension: i32, difficulty: u8, gamemode: u8, level_type: String) -> ClientboundPacket {
        ClientboundPacket::Respawn(Respawn {
            dimension: dimension,
            difficulty: difficulty,
            gamemode: gamemode,
            level_type: level_type,
        })
    }
    /// Get the integer value for the dimension the player is spawning in
    pub fn get_dimension(&self) -> &i32 {
        &self.dimension
    }    /// Get the integer value for the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }    /// Get the integer value for the gamemode
    pub fn get_gamemode(&self) -> &u8 {
        &self.gamemode
    }    /// Get the level type
    pub fn get_level_type(&self) -> &String {
        &self.level_type
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityHeadLook {
    entity_id: i32,
    head_yaw: i8,
}

impl EntityHeadLook {
    const PACKET_ID: i32 = 54;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityHeadLook(EntityHeadLook {
            entity_id: read_varint(r)?,
            head_yaw: read_i8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i8(&self.head_yaw, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, head_yaw: i8) -> ClientboundPacket {
        ClientboundPacket::EntityHeadLook(EntityHeadLook {
            entity_id: entity_id,
            head_yaw: head_yaw,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the new head yaw
    pub fn get_head_yaw(&self) -> &i8 {
        &self.head_yaw
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SelectAdvancementTab {
    identifier: Option<String>,
}

impl SelectAdvancementTab {
    const PACKET_ID: i32 = 55;


    pub fn new_raw(identifier: Option<String>) -> ClientboundPacket {
        ClientboundPacket::SelectAdvancementTab(SelectAdvancementTab {
            identifier: identifier,
        })
    }
    /// Get the identifier to switch to. If None, switch to default
    pub fn get_identifier(&self) -> &Option<String> {
        &self.identifier
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct WorldBorder {
    data: Vec<u8>,
}

impl WorldBorder {
    const PACKET_ID: i32 = 56;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::WorldBorder(WorldBorder {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::WorldBorder(WorldBorder {
            data: data,
        })
    }
    /// Get this packet's raw data. This library does not attempt to parse this packet
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Camera {
    entity_id: i32,
}

impl Camera {
    const PACKET_ID: i32 = 57;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::Camera(Camera {
            entity_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::Camera(Camera {
            entity_id: entity_id,
        })
    }
    /// Get the entity ID to set the camera to
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundHeldItemChange {
    slot: u8,
}

impl ClientboundHeldItemChange {
    const PACKET_ID: i32 = 58;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundHeldItemChange(ClientboundHeldItemChange {
            slot: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot: u8) -> ClientboundPacket {
        ClientboundPacket::ClientboundHeldItemChange(ClientboundHeldItemChange {
            slot: slot,
        })
    }
    /// Get the slot number which the player has selected
    pub fn get_slot(&self) -> &u8 {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct DisplayScoreboard {
    position: u8,
    name: String,
}

impl DisplayScoreboard {
    const PACKET_ID: i32 = 59;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::DisplayScoreboard(DisplayScoreboard {
            position: read_u8(r)?,
            name: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.position, &mut ret)?;
        write_String(&self.name, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: u8, name: String) -> ClientboundPacket {
        ClientboundPacket::DisplayScoreboard(DisplayScoreboard {
            position: position,
            name: name,
        })
    }
    /// Get the raw integer representing the scoreboard's position
    pub fn get_position(&self) -> &u8 {
        &self.position
    }    /// Get the name of the scoreboard
    pub fn get_name(&self) -> &String {
        &self.name
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityMetadata {
    entity_id: i32,
    metadata: Vec<u8>,
}

impl EntityMetadata {
    const PACKET_ID: i32 = 60;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityMetadata(EntityMetadata {
            entity_id: read_varint(r)?,
            metadata: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_bytearray_to_end(&self.metadata, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, metadata: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EntityMetadata(EntityMetadata {
            entity_id: entity_id,
            metadata: metadata,
        })
    }
    /// Get the entity ID of the entity which metadata is being updated
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw data for the metadata. This library does not attempt to parse the metadata.
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct AttachEntity {
    attached_entity_id: i32,
    holding_entity_id: i32,
}

impl AttachEntity {
    const PACKET_ID: i32 = 61;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::AttachEntity(AttachEntity {
            attached_entity_id: read_i32(r)?,
            holding_entity_id: read_i32(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i32(&self.attached_entity_id, &mut ret)?;
        write_i32(&self.holding_entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(attached_entity_id: i32, holding_entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::AttachEntity(AttachEntity {
            attached_entity_id: attached_entity_id,
            holding_entity_id: holding_entity_id,
        })
    }
    /// Get the entity ID of the entity that has been attached
    pub fn get_attached_entity_id(&self) -> &i32 {
        &self.attached_entity_id
    }    /// Get the entity ID of the entity that has been attached to
    pub fn get_holding_entity_id(&self) -> &i32 {
        &self.holding_entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityVelocity {
    entity_id: i32,
    x_velocity: i16,
    y_velocity: i16,
    z_velocity: i16,
}

impl EntityVelocity {
    const PACKET_ID: i32 = 62;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityVelocity(EntityVelocity {
            entity_id: read_varint(r)?,
            x_velocity: read_i16(r)?,
            y_velocity: read_i16(r)?,
            z_velocity: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i16(&self.x_velocity, &mut ret)?;
        write_i16(&self.y_velocity, &mut ret)?;
        write_i16(&self.z_velocity, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x_velocity: i16, y_velocity: i16, z_velocity: i16) -> ClientboundPacket {
        ClientboundPacket::EntityVelocity(EntityVelocity {
            entity_id: entity_id,
            x_velocity: x_velocity,
            y_velocity: y_velocity,
            z_velocity: z_velocity,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the X velocity
    pub fn get_x_velocity(&self) -> &i16 {
        &self.x_velocity
    }    /// Get the Y velocity
    pub fn get_y_velocity(&self) -> &i16 {
        &self.y_velocity
    }    /// Get the Z velocity
    pub fn get_z_velocity(&self) -> &i16 {
        &self.z_velocity
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityEquipment {
    entity_id: i32,
    slot_enum: i32,
    slot_data: Vec<u8>,
}

impl EntityEquipment {
    const PACKET_ID: i32 = 63;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityEquipment(EntityEquipment {
            entity_id: read_varint(r)?,
            slot_enum: read_varint(r)?,
            slot_data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_varint(&self.slot_enum, &mut ret)?;
        write_bytearray_to_end(&self.slot_data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, slot_enum: i32, slot_data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EntityEquipment(EntityEquipment {
            entity_id: entity_id,
            slot_enum: slot_enum,
            slot_data: slot_data,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw slot identification number
    pub fn get_slot_enum(&self) -> &i32 {
        &self.slot_enum
    }    /// Get the raw slot data. This library does not attempt to parse it
    pub fn get_slot_data(&self) -> &Vec<u8> {
        &self.slot_data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetExperience {
    experience: f32,
    level: i32,
    total_experience: i32,
}

impl SetExperience {
    const PACKET_ID: i32 = 64;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetExperience(SetExperience {
            experience: read_f32(r)?,
            level: read_varint(r)?,
            total_experience: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f32(&self.experience, &mut ret)?;
        write_varint(&self.level, &mut ret)?;
        write_varint(&self.total_experience, &mut ret)?;

        Ok(ret)
    }
    pub fn new(experience: f32, level: i32, total_experience: i32) -> ClientboundPacket {
        ClientboundPacket::SetExperience(SetExperience {
            experience: experience,
            level: level,
            total_experience: total_experience,
        })
    }
    /// Get how filled up the experience bar is
    pub fn get_experience(&self) -> &f32 {
        &self.experience
    }    /// Get the new level
    pub fn get_level(&self) -> &i32 {
        &self.level
    }    /// Get the total experience
    pub fn get_total_experience(&self) -> &i32 {
        &self.total_experience
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateHealth {
    health: f32,
    food: i32,
    saturation: f32,
}

impl UpdateHealth {
    const PACKET_ID: i32 = 65;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::UpdateHealth(UpdateHealth {
            health: read_f32(r)?,
            food: read_varint(r)?,
            saturation: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f32(&self.health, &mut ret)?;
        write_varint(&self.food, &mut ret)?;
        write_f32(&self.saturation, &mut ret)?;

        Ok(ret)
    }
    pub fn new(health: f32, food: i32, saturation: f32) -> ClientboundPacket {
        ClientboundPacket::UpdateHealth(UpdateHealth {
            health: health,
            food: food,
            saturation: saturation,
        })
    }
    /// Get how much health the player has
    pub fn get_health(&self) -> &f32 {
        &self.health
    }    /// Get how much food the player has
    pub fn get_food(&self) -> &i32 {
        &self.food
    }    /// Get the saturation level
    pub fn get_saturation(&self) -> &f32 {
        &self.saturation
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ScoreboardObjective {
    name: String,
    mode: u8,
    value: Option<String>,
    objective_type: Option<String>,
}

impl ScoreboardObjective {
    const PACKET_ID: i32 = 66;


    pub fn new_raw(name: String, mode: u8, value: Option<String>, objective_type: Option<String>) -> ClientboundPacket {
        ClientboundPacket::ScoreboardObjective(ScoreboardObjective {
            name: name,
            mode: mode,
            value: value,
            objective_type: objective_type,
        })
    }
    /// Get the name for the object
    pub fn get_name(&self) -> &String {
        &self.name
    }    /// Get the raw mode enum integer
    pub fn get_mode(&self) -> &u8 {
        &self.mode
    }    /// Get the text to be displayed
    pub fn get_value(&self) -> &Option<String> {
        &self.value
    }    /// Get the raw string representing the type (`integer` or `hearts`)
    pub fn get_objective_type(&self) -> &Option<String> {
        &self.objective_type
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetPassengers {
    entity_id: i32,
    passengers: Vec<i32>,
}

impl SetPassengers {
    const PACKET_ID: i32 = 67;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetPassengers(SetPassengers {
            entity_id: read_varint(r)?,
            passengers: read_prefixed_varintarray(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_prefixed_varintarray(&self.passengers, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, passengers: Vec<i32>) -> ClientboundPacket {
        ClientboundPacket::SetPassengers(SetPassengers {
            entity_id: entity_id,
            passengers: passengers,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the vec of all the passengers
    pub fn get_passengers(&self) -> &Vec<i32> {
        &self.passengers
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Teams {
    data: Vec<u8>,
}

impl Teams {
    const PACKET_ID: i32 = 68;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::Teams(Teams {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::Teams(Teams {
            data: data,
        })
    }
    /// Get the raw data, this library does not attempt to parse this packet.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateScore {
    name: String,
    action: u8,
    objective_name: String,
    value: Option<i32>,
}

impl UpdateScore {
    const PACKET_ID: i32 = 69;


    pub fn new_raw(name: String, action: u8, objective_name: String, value: Option<i32>) -> ClientboundPacket {
        ClientboundPacket::UpdateScore(UpdateScore {
            name: name,
            action: action,
            objective_name: objective_name,
            value: value,
        })
    }
    /// Get the name of the score to be updated
    pub fn get_name(&self) -> &String {
        &self.name
    }    /// Get the action being performed
    pub fn get_action(&self) -> &u8 {
        &self.action
    }    /// Get the name of the objective the score belongs to
    pub fn get_objective_name(&self) -> &String {
        &self.objective_name
    }    /// Get the score to be displayed if this packet is updating a score, else `None`
    pub fn get_value(&self) -> &Option<i32> {
        &self.value
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPosition {
    position: (i32, i32, i32),
}

impl SpawnPosition {
    const PACKET_ID: i32 = 70;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPosition(SpawnPosition {
            position: read_position(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32)) -> ClientboundPacket {
        ClientboundPacket::SpawnPosition(SpawnPosition {
            position: position,
        })
    }
    /// Get the position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct TimeUpdate {
    world_age: i64,
    time_of_day: i64,
}

impl TimeUpdate {
    const PACKET_ID: i32 = 71;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::TimeUpdate(TimeUpdate {
            world_age: read_i64(r)?,
            time_of_day: read_i64(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i64(&self.world_age, &mut ret)?;
        write_i64(&self.time_of_day, &mut ret)?;

        Ok(ret)
    }
    pub fn new(world_age: i64, time_of_day: i64) -> ClientboundPacket {
        ClientboundPacket::TimeUpdate(TimeUpdate {
            world_age: world_age,
            time_of_day: time_of_day,
        })
    }
    /// Get the world's age in ticks
    pub fn get_world_age(&self) -> &i64 {
        &self.world_age
    }    /// Get the current time in ticks (0 is sunrise, 6000 is noon, ...)
    pub fn get_time_of_day(&self) -> &i64 {
        &self.time_of_day
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Title {
    action: i32,
    text: Option<String>,
    times: Option<(i32, i32, i32)>,
}

impl Title {
    const PACKET_ID: i32 = 72;


    pub fn new_raw(action: i32, text: Option<String>, times: Option<(i32, i32, i32)>) -> ClientboundPacket {
        ClientboundPacket::Title(Title {
            action: action,
            text: text,
            times: times,
        })
    }
    /// Get the raw action enum integer
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get the title/subtitle/action bar text if action is set title/subtitle/action bar in raw json
    pub fn get_text(&self) -> &Option<String> {
        &self.text
    }    /// If action is 'set times and display' get `Some((fade_in, stay, fade_out))` else get `None`
    pub fn get_times(&self) -> &Option<(i32, i32, i32)> {
        &self.times
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SoundEffect {
    sound_id: i32,
    sound_category: i32,
    x: i32,
    y: i32,
    z: i32,
    volume: f32,
    pitch: f32,
}

impl SoundEffect {
    const PACKET_ID: i32 = 73;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::SoundEffect(SoundEffect {
            sound_id: read_varint(r)?,
            sound_category: read_varint(r)?,
            x: read_i32(r)?,
            y: read_i32(r)?,
            z: read_i32(r)?,
            volume: read_f32(r)?,
            pitch: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.sound_id, &mut ret)?;
        write_varint(&self.sound_category, &mut ret)?;
        write_i32(&self.x, &mut ret)?;
        write_i32(&self.y, &mut ret)?;
        write_i32(&self.z, &mut ret)?;
        write_f32(&self.volume, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(sound_id: i32, sound_category: i32, x: i32, y: i32, z: i32, volume: f32, pitch: f32) -> ClientboundPacket {
        ClientboundPacket::SoundEffect(SoundEffect {
            sound_id: sound_id,
            sound_category: sound_category,
            x: x,
            y: y,
            z: z,
            volume: volume,
            pitch: pitch,
        })
    }
    /// Get the raw sound effect ID. Note that the meaning of this is liable to change between MC releases.
    pub fn get_sound_id(&self) -> &i32 {
        &self.sound_id
    }    /// Get the raw sound category ID.
    pub fn get_sound_category(&self) -> &i32 {
        &self.sound_category
    }    /// Get the X effect multiplied by 8
    pub fn get_x(&self) -> &i32 {
        &self.x
    }    /// Get the Y effect multiplied by 8
    pub fn get_y(&self) -> &i32 {
        &self.y
    }    /// Get the Z effect multiplied by 8
    pub fn get_z(&self) -> &i32 {
        &self.z
    }    /// Get the volume where 1.0 is 100%
    pub fn get_volume(&self) -> &f32 {
        &self.volume
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerListHeaderFooter {
    header: String,
    footer: String,
}

impl PlayerListHeaderFooter {
    const PACKET_ID: i32 = 74;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerListHeaderFooter(PlayerListHeaderFooter {
            header: read_String(r)?,
            footer: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.header, &mut ret)?;
        write_String(&self.footer, &mut ret)?;

        Ok(ret)
    }
    pub fn new(header: String, footer: String) -> ClientboundPacket {
        ClientboundPacket::PlayerListHeaderFooter(PlayerListHeaderFooter {
            header: header,
            footer: footer,
        })
    }
    /// Get the raw json data for the header
    pub fn get_header(&self) -> &String {
        &self.header
    }    /// Get the raw json data for the footer
    pub fn get_footer(&self) -> &String {
        &self.footer
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CollectItem {
    collected_entity_id: i32,
    collector_entity_id: i32,
    item_count: i32,
}

impl CollectItem {
    const PACKET_ID: i32 = 75;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::CollectItem(CollectItem {
            collected_entity_id: read_varint(r)?,
            collector_entity_id: read_varint(r)?,
            item_count: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.collected_entity_id, &mut ret)?;
        write_varint(&self.collector_entity_id, &mut ret)?;
        write_varint(&self.item_count, &mut ret)?;

        Ok(ret)
    }
    pub fn new(collected_entity_id: i32, collector_entity_id: i32, item_count: i32) -> ClientboundPacket {
        ClientboundPacket::CollectItem(CollectItem {
            collected_entity_id: collected_entity_id,
            collector_entity_id: collector_entity_id,
            item_count: item_count,
        })
    }
    /// Get the entity ID of the collected item
    pub fn get_collected_entity_id(&self) -> &i32 {
        &self.collected_entity_id
    }    /// Get the entity ID of the person picking up the item
    pub fn get_collector_entity_id(&self) -> &i32 {
        &self.collector_entity_id
    }    /// Get how many items were picked up
    pub fn get_item_count(&self) -> &i32 {
        &self.item_count
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityTeleport {
    entity_id: i32,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityTeleport {
    const PACKET_ID: i32 = 76;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityTeleport(EntityTeleport {
            entity_id: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: f64, y: f64, z: f64, yaw: i8, pitch: i8, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityTeleport(EntityTeleport {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID of the entity teleported
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the X coordinate the entity moved to
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate the entity moved to
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate the entity moved to
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the (absolute) yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get whether the entity is now on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Advancements {
    data: Vec<u8>,
}

impl Advancements {
    const PACKET_ID: i32 = 77;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::Advancements(Advancements {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::Advancements(Advancements {
            data: data,
        })
    }
    /// Get the raw data for the packet. Parsing it is out of the scope of this library
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityProperties {
    entity_id: i32,
    data: Vec<u8>,
}

impl EntityProperties {
    const PACKET_ID: i32 = 78;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityProperties(EntityProperties {
            entity_id: read_varint(r)?,
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EntityProperties(EntityProperties {
            entity_id: entity_id,
            data: data,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw data for this packet. This library does not attempt to parse the packet
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityEffect {
    entity_id: i32,
    effect_id: u8,
    amplifier: i8,
    duration: i32,
    flags: u8,
}

impl EntityEffect {
    const PACKET_ID: i32 = 79;
    fn deserialize<R: Read>(r: &mut R) -> Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityEffect(EntityEffect {
            entity_id: read_varint(r)?,
            effect_id: read_u8(r)?,
            amplifier: read_i8(r)?,
            duration: read_varint(r)?,
            flags: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.effect_id, &mut ret)?;
        write_i8(&self.amplifier, &mut ret)?;
        write_varint(&self.duration, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, effect_id: u8, amplifier: i8, duration: i32, flags: u8) -> ClientboundPacket {
        ClientboundPacket::EntityEffect(EntityEffect {
            entity_id: entity_id,
            effect_id: effect_id,
            amplifier: amplifier,
            duration: duration,
            flags: flags,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw effect ID integer enum
    pub fn get_effect_id(&self) -> &u8 {
        &self.effect_id
    }    /// Get the amplifier = effect level - 1
    pub fn get_amplifier(&self) -> &i8 {
        &self.amplifier
    }    /// Get the duration of the effect in seconds
    pub fn get_duration(&self) -> &i32 {
        &self.duration
    }    /// Get the raw flags byte
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }
}

