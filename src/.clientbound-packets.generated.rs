/* This file is automatically generated by packets.clj
Do not manually edit this file, if you wish to make
changes here, then edit and rerun packets.clj */

#[derive(Debug, PartialEq, Clone)]
pub struct StatusResponse {
    json: String,
}

impl StatusResponse {
    fn get_packet_id() -> i32 {
        0
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::StatusResponse(StatusResponse {
            json: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&StatusResponse::get_packet_id(), &mut ret)?;
        write_String(&self.json, &mut ret)?;

        Ok(ret)
    }
    pub fn new(json: String) -> ClientboundPacket {
        ClientboundPacket::StatusResponse(StatusResponse {
            json: json,
        })
    }
    /// Get the raw json response
    pub fn get_json(&self) -> &String {
        &self.json
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusPong {
    id: u64,
}

impl StatusPong {
    fn get_packet_id() -> i32 {
        1
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::StatusPong(StatusPong {
            id: read_u64(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&StatusPong::get_packet_id(), &mut ret)?;
        write_u64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: u64) -> ClientboundPacket {
        ClientboundPacket::StatusPong(StatusPong {
            id: id,
        })
    }
    /// Get the id of the ping/pong
    pub fn get_id(&self) -> &u64 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginDisconnect {
    raw_chat: String,
}

impl LoginDisconnect {
    fn get_packet_id() -> i32 {
        0
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::LoginDisconnect(LoginDisconnect {
            raw_chat: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&LoginDisconnect::get_packet_id(), &mut ret)?;
        write_String(&self.raw_chat, &mut ret)?;

        Ok(ret)
    }
    pub fn new(raw_chat: String) -> ClientboundPacket {
        ClientboundPacket::LoginDisconnect(LoginDisconnect {
            raw_chat: raw_chat,
        })
    }
    /// Get the raw chat json
    pub fn get_raw_chat(&self) -> &String {
        &self.raw_chat
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EncryptionRequest {
    server_id: String,
    public_key: Vec<u8>,
    verify_token: Vec<u8>,
}

impl EncryptionRequest {
    fn get_packet_id() -> i32 {
        1
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EncryptionRequest(EncryptionRequest {
            server_id: read_String(r)?,
            public_key: read_prefixed_bytearray(r)?,
            verify_token: read_prefixed_bytearray(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EncryptionRequest::get_packet_id(), &mut ret)?;
        write_String(&self.server_id, &mut ret)?;
        write_prefixed_bytearray(&self.public_key, &mut ret)?;
        write_prefixed_bytearray(&self.verify_token, &mut ret)?;

        Ok(ret)
    }
    pub fn new(server_id: String, public_key: Vec<u8>, verify_token: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EncryptionRequest(EncryptionRequest {
            server_id: server_id,
            public_key: public_key,
            verify_token: verify_token,
        })
    }
    /// Get the server id
    pub fn get_server_id(&self) -> &String {
        &self.server_id
    }    /// Get the public key
    pub fn get_public_key(&self) -> &Vec<u8> {
        &self.public_key
    }    /// Get the verify token
    pub fn get_verify_token(&self) -> &Vec<u8> {
        &self.verify_token
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginSuccess {
    uuid: u128,
    username: String,
}

impl LoginSuccess {
    fn get_packet_id() -> i32 {
        2
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::LoginSuccess(LoginSuccess {
            uuid: read_uuid_str(r)?,
            username: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&LoginSuccess::get_packet_id(), &mut ret)?;
        write_uuid_str(&self.uuid, &mut ret)?;
        write_String(&self.username, &mut ret)?;

        Ok(ret)
    }
    pub fn new(uuid: u128, username: String) -> ClientboundPacket {
        ClientboundPacket::LoginSuccess(LoginSuccess {
            uuid: uuid,
            username: username,
        })
    }
    /// Get the player's uuid
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the player's name
    pub fn get_username(&self) -> &String {
        &self.username
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetCompression {
    threshold: i32,
}

impl SetCompression {
    fn get_packet_id() -> i32 {
        3
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetCompression(SetCompression {
            threshold: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SetCompression::get_packet_id(), &mut ret)?;
        write_varint(&self.threshold, &mut ret)?;

        Ok(ret)
    }
    pub fn new(threshold: i32) -> ClientboundPacket {
        ClientboundPacket::SetCompression(SetCompression {
            threshold: threshold,
        })
    }
    /// Get the compression threshold
    pub fn get_threshold(&self) -> &i32 {
        &self.threshold
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnObject {
    entity_id: i32,
    object_uuid: u128,
    object_type: u8,
    x: f64,
    y: f64,
    z: f64,
    pitch: i8,
    yaw: i8,
    data: i32,
    velocity_x: i16,
    velocity_y: i16,
    velocity_z: i16,
}

impl SpawnObject {
    fn get_packet_id() -> i32 {
        0
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnObject(SpawnObject {
            entity_id: read_varint(r)?,
            object_uuid: read_uuid(r)?,
            object_type: read_u8(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            pitch: read_i8(r)?,
            yaw: read_i8(r)?,
            data: read_i32(r)?,
            velocity_x: read_i16(r)?,
            velocity_y: read_i16(r)?,
            velocity_z: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SpawnObject::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.object_uuid, &mut ret)?;
        write_u8(&self.object_type, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i32(&self.data, &mut ret)?;
        write_i16(&self.velocity_x, &mut ret)?;
        write_i16(&self.velocity_y, &mut ret)?;
        write_i16(&self.velocity_z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, object_uuid: u128, object_type: u8, x: f64, y: f64, z: f64, pitch: i8, yaw: i8, data: i32, velocity_x: i16, velocity_y: i16, velocity_z: i16) -> ClientboundPacket {
        ClientboundPacket::SpawnObject(SpawnObject {
            entity_id: entity_id,
            object_uuid: object_uuid,
            object_type: object_type,
            x: x,
            y: y,
            z: z,
            pitch: pitch,
            yaw: yaw,
            data: data,
            velocity_x: velocity_x,
            velocity_y: velocity_y,
            velocity_z: velocity_z,
        })
    }
    /// Get the ID of the created object
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the created object
    pub fn get_object_uuid(&self) -> &u128 {
        &self.object_uuid
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the X velocity
    pub fn get_velocity_x(&self) -> &i16 {
        &self.velocity_x
    }    /// Get the Y velocity
    pub fn get_velocity_y(&self) -> &i16 {
        &self.velocity_y
    }    /// Get the Z velocity
    pub fn get_velocity_z(&self) -> &i16 {
        &self.velocity_z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnExperienceOrb {
    entity_id: i32,
    x: f64,
    y: f64,
    z: f64,
    count: i16,
}

impl SpawnExperienceOrb {
    fn get_packet_id() -> i32 {
        1
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnExperienceOrb(SpawnExperienceOrb {
            entity_id: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            count: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SpawnExperienceOrb::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i16(&self.count, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: f64, y: f64, z: f64, count: i16) -> ClientboundPacket {
        ClientboundPacket::SpawnExperienceOrb(SpawnExperienceOrb {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            count: count,
        })
    }
    /// Get the ID of the orb
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the amount of experience this orb will reward
    pub fn get_count(&self) -> &i16 {
        &self.count
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnGlobalEntity {
    entity_id: i32,
    entity_type: u8,
    x: f64,
    y: f64,
    z: f64,
}

impl SpawnGlobalEntity {
    fn get_packet_id() -> i32 {
        2
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnGlobalEntity(SpawnGlobalEntity {
            entity_id: read_varint(r)?,
            entity_type: read_u8(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SpawnGlobalEntity::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.entity_type, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, entity_type: u8, x: f64, y: f64, z: f64) -> ClientboundPacket {
        ClientboundPacket::SpawnGlobalEntity(SpawnGlobalEntity {
            entity_id: entity_id,
            entity_type: entity_type,
            x: x,
            y: y,
            z: z,
        })
    }
    /// Get the ID of the entity
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnMob {
    entity_id: i32,
    uuid: u128,
    mob_type: i32,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    head_pitch: i8,
    velocity_x: i16,
    velocity_y: i16,
    velocity_z: i16,
    metadata: Vec<u8>,
}

impl SpawnMob {
    fn get_packet_id() -> i32 {
        3
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnMob(SpawnMob {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            mob_type: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            head_pitch: read_i8(r)?,
            velocity_x: read_i16(r)?,
            velocity_y: read_i16(r)?,
            velocity_z: read_i16(r)?,
            metadata: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SpawnMob::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.uuid, &mut ret)?;
        write_varint(&self.mob_type, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_i8(&self.head_pitch, &mut ret)?;
        write_i16(&self.velocity_x, &mut ret)?;
        write_i16(&self.velocity_y, &mut ret)?;
        write_i16(&self.velocity_z, &mut ret)?;
        write_bytearray_to_end(&self.metadata, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, uuid: u128, mob_type: i32, x: f64, y: f64, z: f64, yaw: i8, pitch: i8, head_pitch: i8, velocity_x: i16, velocity_y: i16, velocity_z: i16, metadata: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::SpawnMob(SpawnMob {
            entity_id: entity_id,
            uuid: uuid,
            mob_type: mob_type,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            head_pitch: head_pitch,
            velocity_x: velocity_x,
            velocity_y: velocity_y,
            velocity_z: velocity_z,
            metadata: metadata,
        })
    }
    /// Get the ID of the mob
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the mob
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the type ID of the mob
    pub fn get_mob_type(&self) -> &i32 {
        &self.mob_type
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw of the mob
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the pitch of the mob
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get the pitch of the head of the mob
    pub fn get_head_pitch(&self) -> &i8 {
        &self.head_pitch
    }    /// Get the X velocity
    pub fn get_velocity_x(&self) -> &i16 {
        &self.velocity_x
    }    /// Get the Y velocity
    pub fn get_velocity_y(&self) -> &i16 {
        &self.velocity_y
    }    /// Get the Z velocity
    pub fn get_velocity_z(&self) -> &i16 {
        &self.velocity_z
    }    /// Get the raw metadata field. This library does not currently attempt to parse this field
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPainting {
    entity_id: i32,
    uuid: u128,
    title: String,
    center_location: (i32, i32, i32),
    direction: u8,
}

impl SpawnPainting {
    fn get_packet_id() -> i32 {
        4
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPainting(SpawnPainting {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            title: read_String(r)?,
            center_location: read_position(r)?,
            direction: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SpawnPainting::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.uuid, &mut ret)?;
        write_String(&self.title, &mut ret)?;
        write_position(&self.center_location, &mut ret)?;
        write_u8(&self.direction, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, uuid: u128, title: String, center_location: (i32, i32, i32), direction: u8) -> ClientboundPacket {
        ClientboundPacket::SpawnPainting(SpawnPainting {
            entity_id: entity_id,
            uuid: uuid,
            title: title,
            center_location: center_location,
            direction: direction,
        })
    }
    /// Get the entity ID of the painting
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the painting
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the title of the painting
    pub fn get_title(&self) -> &String {
        &self.title
    }    /// The direction in which the painting faces
    pub fn get_direction(&self) -> &u8 {
        &self.direction
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPlayer {
    entity_id: i32,
    uuid: u128,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    metadata: Vec<u8>,
}

impl SpawnPlayer {
    fn get_packet_id() -> i32 {
        5
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPlayer(SpawnPlayer {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            metadata: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SpawnPlayer::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_uuid(&self.uuid, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bytearray_to_end(&self.metadata, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, uuid: u128, x: f64, y: f64, z: f64, yaw: i8, pitch: i8, metadata: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::SpawnPlayer(SpawnPlayer {
            entity_id: entity_id,
            uuid: uuid,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            metadata: metadata,
        })
    }
    /// Get the entity ID of the player
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the UUID of the player
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get the raw metadata in the packet, this library does not attempt to parse this field
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundAnimation {
    entity_id: i32,
    animation: u8,
}

impl ClientboundAnimation {
    fn get_packet_id() -> i32 {
        6
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundAnimation(ClientboundAnimation {
            entity_id: read_varint(r)?,
            animation: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientboundAnimation::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.animation, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, animation: u8) -> ClientboundPacket {
        ClientboundPacket::ClientboundAnimation(ClientboundAnimation {
            entity_id: entity_id,
            animation: animation,
        })
    }
    /// Get the entity ID doing the animation
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the byte ID for what kind of animation it is
    pub fn get_animation(&self) -> &u8 {
        &self.animation
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Statistics {
    values: BTreeMap<String, i32>,
}

impl Statistics {
    fn get_packet_id() -> i32 {
        7
    }


    pub fn new_raw(values: BTreeMap<String, i32>) -> ClientboundPacket {
        ClientboundPacket::Statistics(Statistics {
            values: values,
        })
    }
    /// Get the statistics, with the key being the name of the statistic and the value being the value.
    pub fn get_values(&self) -> &BTreeMap<String, i32> {
        &self.values
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockBreakAnimation {
    entity_id: i32,
}

impl BlockBreakAnimation {
    fn get_packet_id() -> i32 {
        8
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockBreakAnimation(BlockBreakAnimation {
            entity_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&BlockBreakAnimation::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::BlockBreakAnimation(BlockBreakAnimation {
            entity_id: entity_id,
        })
    }
    /// Get the entity ID doing the animation
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateBlockEntity {
    position: (i32, i32, i32),
    action: u8,
    nbt: Vec<u8>,
}

impl UpdateBlockEntity {
    fn get_packet_id() -> i32 {
        9
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UpdateBlockEntity(UpdateBlockEntity {
            position: read_position(r)?,
            action: read_u8(r)?,
            nbt: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&UpdateBlockEntity::get_packet_id(), &mut ret)?;
        write_position(&self.position, &mut ret)?;
        write_u8(&self.action, &mut ret)?;
        write_bytearray_to_end(&self.nbt, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32), action: u8, nbt: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::UpdateBlockEntity(UpdateBlockEntity {
            position: position,
            action: action,
            nbt: nbt,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }    /// Get the action ID being performed
    pub fn get_action(&self) -> &u8 {
        &self.action
    }    /// Get the raw NBT bytes
    pub fn get_nbt(&self) -> &Vec<u8> {
        &self.nbt
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockAction {
    position: (i32, i32, i32),
    action_id: u8,
    action_param: u8,
    block_type: i32,
}

impl BlockAction {
    fn get_packet_id() -> i32 {
        10
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockAction(BlockAction {
            position: read_position(r)?,
            action_id: read_u8(r)?,
            action_param: read_u8(r)?,
            block_type: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&BlockAction::get_packet_id(), &mut ret)?;
        write_position(&self.position, &mut ret)?;
        write_u8(&self.action_id, &mut ret)?;
        write_u8(&self.action_param, &mut ret)?;
        write_varint(&self.block_type, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32), action_id: u8, action_param: u8, block_type: i32) -> ClientboundPacket {
        ClientboundPacket::BlockAction(BlockAction {
            position: position,
            action_id: action_id,
            action_param: action_param,
            block_type: block_type,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }    /// Get the action ID
    pub fn get_action_id(&self) -> &u8 {
        &self.action_id
    }    /// Get the action parameter
    pub fn get_action_param(&self) -> &u8 {
        &self.action_param
    }    /// Get the block type
    pub fn get_block_type(&self) -> &i32 {
        &self.block_type
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockChange {
    position: (i32, i32, i32),
    new_block: i32,
}

impl BlockChange {
    fn get_packet_id() -> i32 {
        11
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockChange(BlockChange {
            position: read_position(r)?,
            new_block: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&BlockChange::get_packet_id(), &mut ret)?;
        write_position(&self.position, &mut ret)?;
        write_varint(&self.new_block, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32), new_block: i32) -> ClientboundPacket {
        ClientboundPacket::BlockChange(BlockChange {
            position: position,
            new_block: new_block,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }    /// Get the new block state ID for the block
    pub fn get_new_block(&self) -> &i32 {
        &self.new_block
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct BossBar {
    data: Vec<u8>,
}

impl BossBar {
    fn get_packet_id() -> i32 {
        12
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::BossBar(BossBar {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&BossBar::get_packet_id(), &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::BossBar(BossBar {
            data: data,
        })
    }
    /// Get the raw data from this packet. Parsing this is very dependent on the specific client, and doing so would be out of scope for this library, therefore parsing this packet is left to the user of the library.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ServerDifficulty {
    difficulty: u8,
}

impl ServerDifficulty {
    fn get_packet_id() -> i32 {
        13
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ServerDifficulty(ServerDifficulty {
            difficulty: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ServerDifficulty::get_packet_id(), &mut ret)?;
        write_u8(&self.difficulty, &mut ret)?;

        Ok(ret)
    }
    pub fn new(difficulty: u8) -> ClientboundPacket {
        ClientboundPacket::ServerDifficulty(ServerDifficulty {
            difficulty: difficulty,
        })
    }
    /// Get the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundTabComplete {
    matches: Vec<String>,
}

impl ClientboundTabComplete {
    fn get_packet_id() -> i32 {
        14
    }


    pub fn new_raw(matches: Vec<String>) -> ClientboundPacket {
        ClientboundPacket::ClientboundTabComplete(ClientboundTabComplete {
            matches: matches,
        })
    }
    /// Get the matches
    pub fn get_matches(&self) -> &Vec<String> {
        &self.matches
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChatMessage {
    chat: String,
    position: u8,
}

impl ChatMessage {
    fn get_packet_id() -> i32 {
        15
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChatMessage(ChatMessage {
            chat: read_String(r)?,
            position: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ChatMessage::get_packet_id(), &mut ret)?;
        write_String(&self.chat, &mut ret)?;
        write_u8(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(chat: String, position: u8) -> ClientboundPacket {
        ClientboundPacket::ChatMessage(ChatMessage {
            chat: chat,
            position: position,
        })
    }
    /// Get the raw JSON data of the chat message
    pub fn get_chat(&self) -> &String {
        &self.chat
    }    /// Get the position of the chat message
    pub fn get_position(&self) -> &u8 {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct MultiBlockChange {
    chunk_x: i32,
    chunk_z: i32,
    changes: Vec<(u8, u8, u8, i32)>,
}

impl MultiBlockChange {
    fn get_packet_id() -> i32 {
        16
    }


    pub fn new_raw(chunk_x: i32, chunk_z: i32, changes: Vec<(u8, u8, u8, i32)>) -> ClientboundPacket {
        ClientboundPacket::MultiBlockChange(MultiBlockChange {
            chunk_x: chunk_x,
            chunk_z: chunk_z,
            changes: changes,
        })
    }
    /// Get the chunk X coordinate
    pub fn get_chunk_x(&self) -> &i32 {
        &self.chunk_x
    }    /// Get the chunk Z coordinate
    pub fn get_chunk_z(&self) -> &i32 {
        &self.chunk_z
    }    /// Get the changes as a vector, in the form of Vec<(x, y, z, new_block_state)>, where the x, y, z are relative to the chunk.
    pub fn get_changes(&self) -> &Vec<(u8, u8, u8, i32)> {
        &self.changes
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundConfirmTransaction {
    window_id: u8,
    action_id: i16,
    accepted: bool,
}

impl ClientboundConfirmTransaction {
    fn get_packet_id() -> i32 {
        17
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundConfirmTransaction(ClientboundConfirmTransaction {
            window_id: read_u8(r)?,
            action_id: read_i16(r)?,
            accepted: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientboundConfirmTransaction::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.action_id, &mut ret)?;
        write_bool(&self.accepted, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, action_id: i16, accepted: bool) -> ClientboundPacket {
        ClientboundPacket::ClientboundConfirmTransaction(ClientboundConfirmTransaction {
            window_id: window_id,
            action_id: action_id,
            accepted: accepted,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the action ID (nonce)
    pub fn get_action_id(&self) -> &i16 {
        &self.action_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundCloseWindow {
    window_id: u8,
}

impl ClientboundCloseWindow {
    fn get_packet_id() -> i32 {
        18
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundCloseWindow(ClientboundCloseWindow {
            window_id: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientboundCloseWindow::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8) -> ClientboundPacket {
        ClientboundPacket::ClientboundCloseWindow(ClientboundCloseWindow {
            window_id: window_id,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct OpenWindow {
    window_id: u8,
    window_type: String,
    window_title: String,
    number_of_slots: u8,
    entity_id: Option<i32>,
}

impl OpenWindow {
    fn get_packet_id() -> i32 {
        19
    }


    pub fn new_raw(window_id: u8, window_type: String, window_title: String, number_of_slots: u8, entity_id: Option<i32>) -> ClientboundPacket {
        ClientboundPacket::OpenWindow(OpenWindow {
            window_id: window_id,
            window_type: window_type,
            window_title: window_title,
            number_of_slots: number_of_slots,
            entity_id: entity_id,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the window type
    pub fn get_window_type(&self) -> &String {
        &self.window_type
    }    /// Get the raw JSON of the window title
    pub fn get_window_title(&self) -> &String {
        &self.window_title
    }    /// Get the number of slots in the window
    pub fn get_number_of_slots(&self) -> &u8 {
        &self.number_of_slots
    }    /// Get the entity ID if the window type is `EntityHorse`, else `None`
    pub fn get_entity_id(&self) -> &Option<i32> {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct WindowItems {
    window_id: u8,
    slots: Vec<u8>,
}

impl WindowItems {
    fn get_packet_id() -> i32 {
        20
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::WindowItems(WindowItems {
            window_id: read_u8(r)?,
            slots: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&WindowItems::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_bytearray_to_end(&self.slots, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, slots: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::WindowItems(WindowItems {
            window_id: window_id,
            slots: slots,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the remaining slot data, that is the last two fields described at http://wiki.vg/Protocol#Window_Items
    pub fn get_slots(&self) -> &Vec<u8> {
        &self.slots
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct WindowProperty {
    window_id: u8,
    property: i16,
    new_value: i16,
}

impl WindowProperty {
    fn get_packet_id() -> i32 {
        21
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::WindowProperty(WindowProperty {
            window_id: read_u8(r)?,
            property: read_i16(r)?,
            new_value: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&WindowProperty::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.property, &mut ret)?;
        write_i16(&self.new_value, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, property: i16, new_value: i16) -> ClientboundPacket {
        ClientboundPacket::WindowProperty(WindowProperty {
            window_id: window_id,
            property: property,
            new_value: new_value,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the property being updated
    pub fn get_property(&self) -> &i16 {
        &self.property
    }    /// Get the new value of the propery
    pub fn get_new_value(&self) -> &i16 {
        &self.new_value
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetSlot {
    window_id: u8,
    slot_id: i16,
    slot_data: Vec<u8>,
}

impl SetSlot {
    fn get_packet_id() -> i32 {
        22
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetSlot(SetSlot {
            window_id: read_u8(r)?,
            slot_id: read_i16(r)?,
            slot_data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SetSlot::get_packet_id(), &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_bytearray_to_end(&self.slot_data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, slot_id: i16, slot_data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::SetSlot(SetSlot {
            window_id: window_id,
            slot_id: slot_id,
            slot_data: slot_data,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the ID of the slot to be updated
    pub fn get_slot_id(&self) -> &i16 {
        &self.slot_id
    }    /// Get the slot data of the packet in raw, unprocessed format
    pub fn get_slot_data(&self) -> &Vec<u8> {
        &self.slot_data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetCooldown {
    item_id: i32,
    cooldown: i32,
}

impl SetCooldown {
    fn get_packet_id() -> i32 {
        23
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetCooldown(SetCooldown {
            item_id: read_varint(r)?,
            cooldown: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SetCooldown::get_packet_id(), &mut ret)?;
        write_varint(&self.item_id, &mut ret)?;
        write_varint(&self.cooldown, &mut ret)?;

        Ok(ret)
    }
    pub fn new(item_id: i32, cooldown: i32) -> ClientboundPacket {
        ClientboundPacket::SetCooldown(SetCooldown {
            item_id: item_id,
            cooldown: cooldown,
        })
    }
    /// Get the ID of the item the cool applied to
    pub fn get_item_id(&self) -> &i32 {
        &self.item_id
    }    /// Get the cooldown on the item specified in ticks
    pub fn get_cooldown(&self) -> &i32 {
        &self.cooldown
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundPluginMessage {
    channel: String,
    data: Vec<u8>,
}

impl ClientboundPluginMessage {
    fn get_packet_id() -> i32 {
        24
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundPluginMessage(ClientboundPluginMessage {
            channel: read_String(r)?,
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientboundPluginMessage::get_packet_id(), &mut ret)?;
        write_String(&self.channel, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(channel: String, data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::ClientboundPluginMessage(ClientboundPluginMessage {
            channel: channel,
            data: data,
        })
    }
    /// Get the channel
    pub fn get_channel(&self) -> &String {
        &self.channel
    }    /// Get the raw data
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct NamedSoundEffect {
    sound_name: String,
    sound_category: i32,
    x: i32,
    y: i32,
    z: i32,
    volume: f32,
    pitch: f32,
}

impl NamedSoundEffect {
    fn get_packet_id() -> i32 {
        25
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::NamedSoundEffect(NamedSoundEffect {
            sound_name: read_String(r)?,
            sound_category: read_varint(r)?,
            x: read_i32(r)?,
            y: read_i32(r)?,
            z: read_i32(r)?,
            volume: read_f32(r)?,
            pitch: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&NamedSoundEffect::get_packet_id(), &mut ret)?;
        write_String(&self.sound_name, &mut ret)?;
        write_varint(&self.sound_category, &mut ret)?;
        write_i32(&self.x, &mut ret)?;
        write_i32(&self.y, &mut ret)?;
        write_i32(&self.z, &mut ret)?;
        write_f32(&self.volume, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(sound_name: String, sound_category: i32, x: i32, y: i32, z: i32, volume: f32, pitch: f32) -> ClientboundPacket {
        ClientboundPacket::NamedSoundEffect(NamedSoundEffect {
            sound_name: sound_name,
            sound_category: sound_category,
            x: x,
            y: y,
            z: z,
            volume: volume,
            pitch: pitch,
        })
    }
    /// Get the name of the sound
    pub fn get_sound_name(&self) -> &String {
        &self.sound_name
    }    /// Get the category of the sound
    pub fn get_sound_category(&self) -> &i32 {
        &self.sound_category
    }    /// Get the X coordinate multiplied by 8
    pub fn get_x(&self) -> &i32 {
        &self.x
    }    /// Get the Y coordinate multiplied by 8
    pub fn get_y(&self) -> &i32 {
        &self.y
    }    /// Get the Z coordinate multiplied by 8
    pub fn get_z(&self) -> &i32 {
        &self.z
    }    /// Get the volume
    pub fn get_volume(&self) -> &f32 {
        &self.volume
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayDisconnect {
    reason: String,
}

impl PlayDisconnect {
    fn get_packet_id() -> i32 {
        26
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayDisconnect(PlayDisconnect {
            reason: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayDisconnect::get_packet_id(), &mut ret)?;
        write_String(&self.reason, &mut ret)?;

        Ok(ret)
    }
    pub fn new(reason: String) -> ClientboundPacket {
        ClientboundPacket::PlayDisconnect(PlayDisconnect {
            reason: reason,
        })
    }
    /// Get the reason in raw json format
    pub fn get_reason(&self) -> &String {
        &self.reason
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityStatus {
    entity_id: i32,
    status: u8,
}

impl EntityStatus {
    fn get_packet_id() -> i32 {
        27
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityStatus(EntityStatus {
            entity_id: read_i32(r)?,
            status: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityStatus::get_packet_id(), &mut ret)?;
        write_i32(&self.entity_id, &mut ret)?;
        write_u8(&self.status, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, status: u8) -> ClientboundPacket {
        ClientboundPacket::EntityStatus(EntityStatus {
            entity_id: entity_id,
            status: status,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the status of the entity
    pub fn get_status(&self) -> &u8 {
        &self.status
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Explosion {
    x: f32,
    y: f32,
    z: f32,
    radius: f32,
    affected_blocks: Vec<(i8, i8, i8)>,
    motion_x: f32,
    motion_y: f32,
    motion_z: f32,
}

impl Explosion {
    fn get_packet_id() -> i32 {
        28
    }


    pub fn new_raw(x: f32, y: f32, z: f32, radius: f32, affected_blocks: Vec<(i8, i8, i8)>, motion_x: f32, motion_y: f32, motion_z: f32) -> ClientboundPacket {
        ClientboundPacket::Explosion(Explosion {
            x: x,
            y: y,
            z: z,
            radius: radius,
            affected_blocks: affected_blocks,
            motion_x: motion_x,
            motion_y: motion_y,
            motion_z: motion_z,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f32 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f32 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f32 {
        &self.z
    }    /// Get the radius
    pub fn get_radius(&self) -> &f32 {
        &self.radius
    }    /// A list of the blocks affected by the explosion, given in Vec<(x, y, z)> where x, y, z are offsets from the explosions center
    pub fn get_affected_blocks(&self) -> &Vec<(i8, i8, i8)> {
        &self.affected_blocks
    }    /// Get the motion in the X direction that the player suffers as a result of the explosion
    pub fn get_motion_x(&self) -> &f32 {
        &self.motion_x
    }    /// Get the motion in the Y direction that the player suffers as a result of the explosion
    pub fn get_motion_y(&self) -> &f32 {
        &self.motion_y
    }    /// Get the motion in the Z direction that the player suffers as a result of the explosion
    pub fn get_motion_z(&self) -> &f32 {
        &self.motion_z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UnloadChunk {
    chunk_x: i32,
    chunk_z: i32,
}

impl UnloadChunk {
    fn get_packet_id() -> i32 {
        29
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UnloadChunk(UnloadChunk {
            chunk_x: read_i32(r)?,
            chunk_z: read_i32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&UnloadChunk::get_packet_id(), &mut ret)?;
        write_i32(&self.chunk_x, &mut ret)?;
        write_i32(&self.chunk_z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(chunk_x: i32, chunk_z: i32) -> ClientboundPacket {
        ClientboundPacket::UnloadChunk(UnloadChunk {
            chunk_x: chunk_x,
            chunk_z: chunk_z,
        })
    }
    /// Get the chunk's X coordinate
    pub fn get_chunk_x(&self) -> &i32 {
        &self.chunk_x
    }    /// Get the chunk's Z coordinate
    pub fn get_chunk_z(&self) -> &i32 {
        &self.chunk_z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChangeGameState {
    action: u8,
    value: f32,
}

impl ChangeGameState {
    fn get_packet_id() -> i32 {
        30
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChangeGameState(ChangeGameState {
            action: read_u8(r)?,
            value: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ChangeGameState::get_packet_id(), &mut ret)?;
        write_u8(&self.action, &mut ret)?;
        write_f32(&self.value, &mut ret)?;

        Ok(ret)
    }
    pub fn new(action: u8, value: f32) -> ClientboundPacket {
        ClientboundPacket::ChangeGameState(ChangeGameState {
            action: action,
            value: value,
        })
    }
    /// Get the reason for the change as a byte
    pub fn get_action(&self) -> &u8 {
        &self.action
    }    /// Get the value, its meaning depends on the action
    pub fn get_value(&self) -> &f32 {
        &self.value
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct KeepAlive {
    id: i32,
}

impl KeepAlive {
    fn get_packet_id() -> i32 {
        31
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::KeepAlive(KeepAlive {
            id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&KeepAlive::get_packet_id(), &mut ret)?;
        write_varint(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i32) -> ClientboundPacket {
        ClientboundPacket::KeepAlive(KeepAlive {
            id: id,
        })
    }
    /// Get the ID of the keep alive packet
    pub fn get_id(&self) -> &i32 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChunkData {
    data: Vec<u8>,
}

impl ChunkData {
    fn get_packet_id() -> i32 {
        32
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChunkData(ChunkData {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ChunkData::get_packet_id(), &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::ChunkData(ChunkData {
            data: data,
        })
    }
    /// Get all the data contained in this packet. Currently it's decided that this library shouldn't try to interpret complex data structures that are likely dependent on the specific implementation, so the parsing of this packet is left up to the client.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Effect {
    effect_id: i32,
    location: (i32, i32, i32),
    data: i32,
    disable_relative_volume: bool,
}

impl Effect {
    fn get_packet_id() -> i32 {
        33
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Effect(Effect {
            effect_id: read_i32(r)?,
            location: read_position(r)?,
            data: read_i32(r)?,
            disable_relative_volume: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Effect::get_packet_id(), &mut ret)?;
        write_i32(&self.effect_id, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_i32(&self.data, &mut ret)?;
        write_bool(&self.disable_relative_volume, &mut ret)?;

        Ok(ret)
    }
    pub fn new(effect_id: i32, location: (i32, i32, i32), data: i32, disable_relative_volume: bool) -> ClientboundPacket {
        ClientboundPacket::Effect(Effect {
            effect_id: effect_id,
            location: location,
            data: data,
            disable_relative_volume: disable_relative_volume,
        })
    }
    /// Get the ID of the effect
    pub fn get_effect_id(&self) -> &i32 {
        &self.effect_id
    }    /// Get the data for this effect
    pub fn get_data(&self) -> &i32 {
        &self.data
    }    /// Get whether to disable relative volume
    pub fn get_disable_relative_volume(&self) -> &bool {
        &self.disable_relative_volume
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Particle {
    particle_id: i32,
    use_long_distance: bool,
    x: f32,
    y: f32,
    z: f32,
    offset_x: f32,
    offset_y: f32,
    offset_z: f32,
    particle_data: f32,
    count: i32,
    id: Option<i32>,
    crack_data: Option<i32>,
}

impl Particle {
    fn get_packet_id() -> i32 {
        34
    }


    pub fn new_raw(particle_id: i32, use_long_distance: bool, x: f32, y: f32, z: f32, offset_x: f32, offset_y: f32, offset_z: f32, particle_data: f32, count: i32, id: Option<i32>, crack_data: Option<i32>) -> ClientboundPacket {
        ClientboundPacket::Particle(Particle {
            particle_id: particle_id,
            use_long_distance: use_long_distance,
            x: x,
            y: y,
            z: z,
            offset_x: offset_x,
            offset_y: offset_y,
            offset_z: offset_z,
            particle_data: particle_data,
            count: count,
            id: id,
            crack_data: crack_data,
        })
    }
    /// Get the particle ID
    pub fn get_particle_id(&self) -> &i32 {
        &self.particle_id
    }    /// Get whether to use long distance (65536) instead of short (256)
    pub fn get_use_long_distance(&self) -> &bool {
        &self.use_long_distance
    }    /// Get the X coordinate
    pub fn get_x(&self) -> &f32 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f32 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f32 {
        &self.z
    }    /// Get the X offset
    pub fn get_offset_x(&self) -> &f32 {
        &self.offset_x
    }    /// Get the Y offset
    pub fn get_offset_y(&self) -> &f32 {
        &self.offset_y
    }    /// Get the Z offset
    pub fn get_offset_z(&self) -> &f32 {
        &self.offset_z
    }    /// Get the particle data for each particle
    pub fn get_particle_data(&self) -> &f32 {
        &self.particle_data
    }    /// Get the amount of particles to create
    pub fn get_count(&self) -> &i32 {
        &self.count
    }    /// Get the id for iconcrack, blockcrack and blockdust
    pub fn get_id(&self) -> &Option<i32> {
        &self.id
    }    /// Get the data for iconcrack and blockcrack
    pub fn get_crack_data(&self) -> &Option<i32> {
        &self.crack_data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct JoinGame {
    entity_id: i32,
    gamemode: u8,
    dimension: i32,
    difficulty: u8,
    max_players: u8,
    level_type: String,
    reduced_debug: bool,
}

impl JoinGame {
    fn get_packet_id() -> i32 {
        35
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::JoinGame(JoinGame {
            entity_id: read_i32(r)?,
            gamemode: read_u8(r)?,
            dimension: read_i32(r)?,
            difficulty: read_u8(r)?,
            max_players: read_u8(r)?,
            level_type: read_String(r)?,
            reduced_debug: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&JoinGame::get_packet_id(), &mut ret)?;
        write_i32(&self.entity_id, &mut ret)?;
        write_u8(&self.gamemode, &mut ret)?;
        write_i32(&self.dimension, &mut ret)?;
        write_u8(&self.difficulty, &mut ret)?;
        write_u8(&self.max_players, &mut ret)?;
        write_String(&self.level_type, &mut ret)?;
        write_bool(&self.reduced_debug, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, gamemode: u8, dimension: i32, difficulty: u8, max_players: u8, level_type: String, reduced_debug: bool) -> ClientboundPacket {
        ClientboundPacket::JoinGame(JoinGame {
            entity_id: entity_id,
            gamemode: gamemode,
            dimension: dimension,
            difficulty: difficulty,
            max_players: max_players,
            level_type: level_type,
            reduced_debug: reduced_debug,
        })
    }
    /// Get the player's entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the player's gamemode
    pub fn get_gamemode(&self) -> &u8 {
        &self.gamemode
    }    /// Get the dimension the player is in. Not the specific world (in case of servers with multiworld), but the kind of world
    pub fn get_dimension(&self) -> &i32 {
        &self.dimension
    }    /// Get the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }    /// Get the level type of the world the player joined in
    pub fn get_level_type(&self) -> &String {
        &self.level_type
    }    /// Get whether to show reduced debug info
    pub fn get_reduced_debug(&self) -> &bool {
        &self.reduced_debug
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Map {
    data: Vec<u8>,
}

impl Map {
    fn get_packet_id() -> i32 {
        36
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Map(Map {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Map::get_packet_id(), &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::Map(Map {
            data: data,
        })
    }
    /// Get the raw data from this packet. Parsing this is very dependent on the specific client, and doing so would be out of scope for this library, therefore parsing this packet is left to the user of the library.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityRelativeMove {
    entity_id: i32,
    x: i16,
    y: i16,
    z: i16,
    on_ground: bool,
}

impl EntityRelativeMove {
    fn get_packet_id() -> i32 {
        37
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityRelativeMove(EntityRelativeMove {
            entity_id: read_varint(r)?,
            x: read_i16(r)?,
            y: read_i16(r)?,
            z: read_i16(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityRelativeMove::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i16(&self.x, &mut ret)?;
        write_i16(&self.y, &mut ret)?;
        write_i16(&self.z, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: i16, y: i16, z: i16, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityRelativeMove(EntityRelativeMove {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the relative distanced moved in the X direction times 128
    pub fn get_x(&self) -> &i16 {
        &self.x
    }    /// Get the relative distanced moved in the Y direction times 128
    pub fn get_y(&self) -> &i16 {
        &self.y
    }    /// Get the relative distanced moved in the Z direction times 128
    pub fn get_z(&self) -> &i16 {
        &self.z
    }    /// Get whether the entity is on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityLookRelativeMove {
    entity_id: i32,
    x: i16,
    y: i16,
    z: i16,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityLookRelativeMove {
    fn get_packet_id() -> i32 {
        38
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityLookRelativeMove(EntityLookRelativeMove {
            entity_id: read_varint(r)?,
            x: read_i16(r)?,
            y: read_i16(r)?,
            z: read_i16(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityLookRelativeMove::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i16(&self.x, &mut ret)?;
        write_i16(&self.y, &mut ret)?;
        write_i16(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: i16, y: i16, z: i16, yaw: i8, pitch: i8, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityLookRelativeMove(EntityLookRelativeMove {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the relative distanced moved in the X direction times 128
    pub fn get_x(&self) -> &i16 {
        &self.x
    }    /// Get the relative distanced moved in the Y direction times 128
    pub fn get_y(&self) -> &i16 {
        &self.y
    }    /// Get the relative distanced moved in the Z direction times 128
    pub fn get_z(&self) -> &i16 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get whether the entity is on the grouns
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityLook {
    entity_id: i32,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityLook {
    fn get_packet_id() -> i32 {
        39
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityLook(EntityLook {
            entity_id: read_varint(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityLook::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, yaw: i8, pitch: i8, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityLook(EntityLook {
            entity_id: entity_id,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the (absolute) angle
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Entity {
    entity_id: i32,
}

impl Entity {
    fn get_packet_id() -> i32 {
        40
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Entity(Entity {
            entity_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Entity::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::Entity(Entity {
            entity_id: entity_id,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundVehicleMove {
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
}

impl ClientboundVehicleMove {
    fn get_packet_id() -> i32 {
        41
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundVehicleMove(ClientboundVehicleMove {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientboundVehicleMove::get_packet_id(), &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: i8, pitch: i8) -> ClientboundPacket {
        ClientboundPacket::ClientboundVehicleMove(ClientboundVehicleMove {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the (absolute) angle
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct OpenSignEditor {
    position: (i32, i32, i32),
}

impl OpenSignEditor {
    fn get_packet_id() -> i32 {
        42
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::OpenSignEditor(OpenSignEditor {
            position: read_position(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&OpenSignEditor::get_packet_id(), &mut ret)?;
        write_position(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32)) -> ClientboundPacket {
        ClientboundPacket::OpenSignEditor(OpenSignEditor {
            position: position,
        })
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerAbilities {
    flags: u8,
    flying_speed: f32,
    fov: f32,
}

impl PlayerAbilities {
    fn get_packet_id() -> i32 {
        43
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerAbilities(PlayerAbilities {
            flags: read_u8(r)?,
            flying_speed: read_f32(r)?,
            fov: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerAbilities::get_packet_id(), &mut ret)?;
        write_u8(&self.flags, &mut ret)?;
        write_f32(&self.flying_speed, &mut ret)?;
        write_f32(&self.fov, &mut ret)?;

        Ok(ret)
    }
    pub fn new(flags: u8, flying_speed: f32, fov: f32) -> ClientboundPacket {
        ClientboundPacket::PlayerAbilities(PlayerAbilities {
            flags: flags,
            flying_speed: flying_speed,
            fov: fov,
        })
    }
    /// Get the player's allowed flying speed
    pub fn get_flying_speed(&self) -> &f32 {
        &self.flying_speed
    }    /// Get the player's field of view modifier
    pub fn get_fov(&self) -> &f32 {
        &self.fov
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CombatEvent {
    event: i32,
    duration_playerid: Option<i32>,
    entity_id: Option<i32>,
    message: Option<String>,
}

impl CombatEvent {
    fn get_packet_id() -> i32 {
        44
    }


    pub fn new_raw(event: i32, duration_playerid: Option<i32>, entity_id: Option<i32>, message: Option<String>) -> ClientboundPacket {
        ClientboundPacket::CombatEvent(CombatEvent {
            event: event,
            duration_playerid: duration_playerid,
            entity_id: entity_id,
            message: message,
        })
    }
    /// Get the entity ID if packet action is 'end combat' or 'entity dead'
    pub fn get_entity_id(&self) -> &Option<i32> {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerListItem {
    data: Vec<u8>,
}

impl PlayerListItem {
    fn get_packet_id() -> i32 {
        45
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerListItem(PlayerListItem {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerListItem::get_packet_id(), &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::PlayerListItem(PlayerListItem {
            data: data,
        })
    }
    /// Get the raw data from this packet. This library does not attempt to parse this packet.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPositionAndLook {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
    flags: u8,
    teleport_id: i32,
}

impl PlayerPositionAndLook {
    fn get_packet_id() -> i32 {
        46
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,
            flags: read_u8(r)?,
            teleport_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerPositionAndLook::get_packet_id(), &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;
        write_varint(&self.teleport_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32, flags: u8, teleport_id: i32) -> ClientboundPacket {
        ClientboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            flags: flags,
            teleport_id: teleport_id,
        })
    }
    /// Get the x coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }    /// Get the raw flags bitmask
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }    /// Get the teleport ID to be used in the serverbound TeleportConfirm packet.
    pub fn get_teleport_id(&self) -> &i32 {
        &self.teleport_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UseBed {
    entity_id: i32,
    position: (i32, i32, i32),
}

impl UseBed {
    fn get_packet_id() -> i32 {
        47
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UseBed(UseBed {
            entity_id: read_varint(r)?,
            position: read_position(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&UseBed::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_position(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, position: (i32, i32, i32)) -> ClientboundPacket {
        ClientboundPacket::UseBed(UseBed {
            entity_id: entity_id,
            position: position,
        })
    }
    /// Get the entity ID of the player sleeping
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct DestroyEntities {
    entity_ids: Vec<i32>,
}

impl DestroyEntities {
    fn get_packet_id() -> i32 {
        48
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::DestroyEntities(DestroyEntities {
            entity_ids: read_prefixed_varintarray(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&DestroyEntities::get_packet_id(), &mut ret)?;
        write_prefixed_varintarray(&self.entity_ids, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_ids: Vec<i32>) -> ClientboundPacket {
        ClientboundPacket::DestroyEntities(DestroyEntities {
            entity_ids: entity_ids,
        })
    }
    /// Get the list of entity IDs that have been destroyed
    pub fn get_entity_ids(&self) -> &Vec<i32> {
        &self.entity_ids
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct RemoveEntityEffect {
    entity_id: i32,
    effect_id: u8,
}

impl RemoveEntityEffect {
    fn get_packet_id() -> i32 {
        49
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::RemoveEntityEffect(RemoveEntityEffect {
            entity_id: read_varint(r)?,
            effect_id: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&RemoveEntityEffect::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.effect_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, effect_id: u8) -> ClientboundPacket {
        ClientboundPacket::RemoveEntityEffect(RemoveEntityEffect {
            entity_id: entity_id,
            effect_id: effect_id,
        })
    }
    /// Get the entity ID to remove the effect from
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ResourcePackSend {
    url: String,
    hash: String,
}

impl ResourcePackSend {
    fn get_packet_id() -> i32 {
        50
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ResourcePackSend(ResourcePackSend {
            url: read_String(r)?,
            hash: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ResourcePackSend::get_packet_id(), &mut ret)?;
        write_String(&self.url, &mut ret)?;
        write_String(&self.hash, &mut ret)?;

        Ok(ret)
    }
    pub fn new(url: String, hash: String) -> ClientboundPacket {
        ClientboundPacket::ResourcePackSend(ResourcePackSend {
            url: url,
            hash: hash,
        })
    }
    /// Get the URL to the resource pack
    pub fn get_url(&self) -> &String {
        &self.url
    }    /// Get the expected SHA-1 hash of the resource pack
    pub fn get_hash(&self) -> &String {
        &self.hash
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Respawn {
    dimension: i32,
    difficulty: u8,
    gamemode: u8,
    level_type: String,
}

impl Respawn {
    fn get_packet_id() -> i32 {
        51
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Respawn(Respawn {
            dimension: read_i32(r)?,
            difficulty: read_u8(r)?,
            gamemode: read_u8(r)?,
            level_type: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Respawn::get_packet_id(), &mut ret)?;
        write_i32(&self.dimension, &mut ret)?;
        write_u8(&self.difficulty, &mut ret)?;
        write_u8(&self.gamemode, &mut ret)?;
        write_String(&self.level_type, &mut ret)?;

        Ok(ret)
    }
    pub fn new(dimension: i32, difficulty: u8, gamemode: u8, level_type: String) -> ClientboundPacket {
        ClientboundPacket::Respawn(Respawn {
            dimension: dimension,
            difficulty: difficulty,
            gamemode: gamemode,
            level_type: level_type,
        })
    }
    /// Get the integer value for the dimension the player is spawning in
    pub fn get_dimension(&self) -> &i32 {
        &self.dimension
    }    /// Get the integer value for the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }    /// Get the integer value for the gamemode
    pub fn get_gamemode(&self) -> &u8 {
        &self.gamemode
    }    /// Get the level type
    pub fn get_level_type(&self) -> &String {
        &self.level_type
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityHeadLook {
    entity_id: i32,
    head_yaw: i8,
}

impl EntityHeadLook {
    fn get_packet_id() -> i32 {
        52
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityHeadLook(EntityHeadLook {
            entity_id: read_varint(r)?,
            head_yaw: read_i8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityHeadLook::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i8(&self.head_yaw, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, head_yaw: i8) -> ClientboundPacket {
        ClientboundPacket::EntityHeadLook(EntityHeadLook {
            entity_id: entity_id,
            head_yaw: head_yaw,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the new head yaw
    pub fn get_head_yaw(&self) -> &i8 {
        &self.head_yaw
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct WorldBorder {
    data: Vec<u8>,
}

impl WorldBorder {
    fn get_packet_id() -> i32 {
        53
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::WorldBorder(WorldBorder {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&WorldBorder::get_packet_id(), &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::WorldBorder(WorldBorder {
            data: data,
        })
    }
    /// Get this packet's raw data. This library does not attempt to parse this packet
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Camera {
    entity_id: i32,
}

impl Camera {
    fn get_packet_id() -> i32 {
        54
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Camera(Camera {
            entity_id: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Camera::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::Camera(Camera {
            entity_id: entity_id,
        })
    }
    /// Get the entity ID to set the camera to
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundHeldItemChange {
    slot: u8,
}

impl ClientboundHeldItemChange {
    fn get_packet_id() -> i32 {
        55
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundHeldItemChange(ClientboundHeldItemChange {
            slot: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&ClientboundHeldItemChange::get_packet_id(), &mut ret)?;
        write_u8(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot: u8) -> ClientboundPacket {
        ClientboundPacket::ClientboundHeldItemChange(ClientboundHeldItemChange {
            slot: slot,
        })
    }
    /// Get the slot number which the player has selected
    pub fn get_slot(&self) -> &u8 {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct DisplayScoreboard {
    position: u8,
    name: String,
}

impl DisplayScoreboard {
    fn get_packet_id() -> i32 {
        56
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::DisplayScoreboard(DisplayScoreboard {
            position: read_u8(r)?,
            name: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&DisplayScoreboard::get_packet_id(), &mut ret)?;
        write_u8(&self.position, &mut ret)?;
        write_String(&self.name, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: u8, name: String) -> ClientboundPacket {
        ClientboundPacket::DisplayScoreboard(DisplayScoreboard {
            position: position,
            name: name,
        })
    }
    /// Get the raw integer representing the scoreboard's position
    pub fn get_position(&self) -> &u8 {
        &self.position
    }    /// Get the name of the scoreboard
    pub fn get_name(&self) -> &String {
        &self.name
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityMetadata {
    entity_id: i32,
    metadata: Vec<u8>,
}

impl EntityMetadata {
    fn get_packet_id() -> i32 {
        57
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityMetadata(EntityMetadata {
            entity_id: read_varint(r)?,
            metadata: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityMetadata::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_bytearray_to_end(&self.metadata, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, metadata: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EntityMetadata(EntityMetadata {
            entity_id: entity_id,
            metadata: metadata,
        })
    }
    /// Get the entity ID of the entity which metadata is being updated
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw data for the metadata. This library does not attempt to parse the metadata.
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct AttachEntity {
    attached_entity_id: i32,
    holding_entity_id: i32,
}

impl AttachEntity {
    fn get_packet_id() -> i32 {
        58
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::AttachEntity(AttachEntity {
            attached_entity_id: read_i32(r)?,
            holding_entity_id: read_i32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&AttachEntity::get_packet_id(), &mut ret)?;
        write_i32(&self.attached_entity_id, &mut ret)?;
        write_i32(&self.holding_entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(attached_entity_id: i32, holding_entity_id: i32) -> ClientboundPacket {
        ClientboundPacket::AttachEntity(AttachEntity {
            attached_entity_id: attached_entity_id,
            holding_entity_id: holding_entity_id,
        })
    }
    /// Get the entity ID of the entity that has been attached
    pub fn get_attached_entity_id(&self) -> &i32 {
        &self.attached_entity_id
    }    /// Get the entity ID of the entity that has been attached to
    pub fn get_holding_entity_id(&self) -> &i32 {
        &self.holding_entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityVelocity {
    entity_id: i32,
    x_velocity: i16,
    y_velocity: i16,
    z_velocity: i16,
}

impl EntityVelocity {
    fn get_packet_id() -> i32 {
        59
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityVelocity(EntityVelocity {
            entity_id: read_varint(r)?,
            x_velocity: read_i16(r)?,
            y_velocity: read_i16(r)?,
            z_velocity: read_i16(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityVelocity::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_i16(&self.x_velocity, &mut ret)?;
        write_i16(&self.y_velocity, &mut ret)?;
        write_i16(&self.z_velocity, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x_velocity: i16, y_velocity: i16, z_velocity: i16) -> ClientboundPacket {
        ClientboundPacket::EntityVelocity(EntityVelocity {
            entity_id: entity_id,
            x_velocity: x_velocity,
            y_velocity: y_velocity,
            z_velocity: z_velocity,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the X velocity
    pub fn get_x_velocity(&self) -> &i16 {
        &self.x_velocity
    }    /// Get the Y velocity
    pub fn get_y_velocity(&self) -> &i16 {
        &self.y_velocity
    }    /// Get the Z velocity
    pub fn get_z_velocity(&self) -> &i16 {
        &self.z_velocity
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityEquipment {
    entity_id: i32,
    slot_enum: i32,
    slot_data: Vec<u8>,
}

impl EntityEquipment {
    fn get_packet_id() -> i32 {
        60
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityEquipment(EntityEquipment {
            entity_id: read_varint(r)?,
            slot_enum: read_varint(r)?,
            slot_data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityEquipment::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_varint(&self.slot_enum, &mut ret)?;
        write_bytearray_to_end(&self.slot_data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, slot_enum: i32, slot_data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EntityEquipment(EntityEquipment {
            entity_id: entity_id,
            slot_enum: slot_enum,
            slot_data: slot_data,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw slot identification number
    pub fn get_slot_enum(&self) -> &i32 {
        &self.slot_enum
    }    /// Get the raw slot data. This library does not attempt to parse it
    pub fn get_slot_data(&self) -> &Vec<u8> {
        &self.slot_data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetExperience {
    experience: f32,
    level: i32,
    total_experience: i32,
}

impl SetExperience {
    fn get_packet_id() -> i32 {
        61
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetExperience(SetExperience {
            experience: read_f32(r)?,
            level: read_varint(r)?,
            total_experience: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SetExperience::get_packet_id(), &mut ret)?;
        write_f32(&self.experience, &mut ret)?;
        write_varint(&self.level, &mut ret)?;
        write_varint(&self.total_experience, &mut ret)?;

        Ok(ret)
    }
    pub fn new(experience: f32, level: i32, total_experience: i32) -> ClientboundPacket {
        ClientboundPacket::SetExperience(SetExperience {
            experience: experience,
            level: level,
            total_experience: total_experience,
        })
    }
    /// Get how filled up the experience bar is
    pub fn get_experience(&self) -> &f32 {
        &self.experience
    }    /// Get the new level
    pub fn get_level(&self) -> &i32 {
        &self.level
    }    /// Get the total experience
    pub fn get_total_experience(&self) -> &i32 {
        &self.total_experience
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateHealth {
    health: f32,
    food: i32,
    saturation: f32,
}

impl UpdateHealth {
    fn get_packet_id() -> i32 {
        62
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UpdateHealth(UpdateHealth {
            health: read_f32(r)?,
            food: read_varint(r)?,
            saturation: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&UpdateHealth::get_packet_id(), &mut ret)?;
        write_f32(&self.health, &mut ret)?;
        write_varint(&self.food, &mut ret)?;
        write_f32(&self.saturation, &mut ret)?;

        Ok(ret)
    }
    pub fn new(health: f32, food: i32, saturation: f32) -> ClientboundPacket {
        ClientboundPacket::UpdateHealth(UpdateHealth {
            health: health,
            food: food,
            saturation: saturation,
        })
    }
    /// Get how much health the player has
    pub fn get_health(&self) -> &f32 {
        &self.health
    }    /// Get how much food the player has
    pub fn get_food(&self) -> &i32 {
        &self.food
    }    /// Get the saturation level
    pub fn get_saturation(&self) -> &f32 {
        &self.saturation
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ScoreboardObjective {
    name: String,
    mode: u8,
    value: Option<String>,
    objective_type: Option<String>,
}

impl ScoreboardObjective {
    fn get_packet_id() -> i32 {
        63
    }


    pub fn new_raw(name: String, mode: u8, value: Option<String>, objective_type: Option<String>) -> ClientboundPacket {
        ClientboundPacket::ScoreboardObjective(ScoreboardObjective {
            name: name,
            mode: mode,
            value: value,
            objective_type: objective_type,
        })
    }
    /// Get the name for the object
    pub fn get_name(&self) -> &String {
        &self.name
    }    /// Get the raw mode enum integer
    pub fn get_mode(&self) -> &u8 {
        &self.mode
    }    /// Get the text to be displayed
    pub fn get_value(&self) -> &Option<String> {
        &self.value
    }    /// Get the raw string representing the type (`integer` or `hearts`)
    pub fn get_objective_type(&self) -> &Option<String> {
        &self.objective_type
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetPassengers {
    entity_id: i32,
    passengers: Vec<i32>,
}

impl SetPassengers {
    fn get_packet_id() -> i32 {
        64
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetPassengers(SetPassengers {
            entity_id: read_varint(r)?,
            passengers: read_prefixed_varintarray(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SetPassengers::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_prefixed_varintarray(&self.passengers, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, passengers: Vec<i32>) -> ClientboundPacket {
        ClientboundPacket::SetPassengers(SetPassengers {
            entity_id: entity_id,
            passengers: passengers,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the vec of all the passengers
    pub fn get_passengers(&self) -> &Vec<i32> {
        &self.passengers
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Teams {
    data: Vec<u8>,
}

impl Teams {
    fn get_packet_id() -> i32 {
        65
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Teams(Teams {
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Teams::get_packet_id(), &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::Teams(Teams {
            data: data,
        })
    }
    /// Get the raw data, this library does not attempt to parse this packet.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateScore {
    name: String,
    action: u8,
    objective_name: String,
    value: Option<i32>,
}

impl UpdateScore {
    fn get_packet_id() -> i32 {
        66
    }


    pub fn new_raw(name: String, action: u8, objective_name: String, value: Option<i32>) -> ClientboundPacket {
        ClientboundPacket::UpdateScore(UpdateScore {
            name: name,
            action: action,
            objective_name: objective_name,
            value: value,
        })
    }
    /// Get the name of the score to be updated
    pub fn get_name(&self) -> &String {
        &self.name
    }    /// Get the action being performed
    pub fn get_action(&self) -> &u8 {
        &self.action
    }    /// Get the name of the objective the score belongs to
    pub fn get_objective_name(&self) -> &String {
        &self.objective_name
    }    /// Get the score to be displayed if this packet is updating a score, else `None`
    pub fn get_value(&self) -> &Option<i32> {
        &self.value
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPosition {
    position: (i32, i32, i32),
}

impl SpawnPosition {
    fn get_packet_id() -> i32 {
        67
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPosition(SpawnPosition {
            position: read_position(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SpawnPosition::get_packet_id(), &mut ret)?;
        write_position(&self.position, &mut ret)?;

        Ok(ret)
    }
    pub fn new(position: (i32, i32, i32)) -> ClientboundPacket {
        ClientboundPacket::SpawnPosition(SpawnPosition {
            position: position,
        })
    }
    /// Get the position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct TimeUpdate {
    world_age: i64,
    time_of_day: i64,
}

impl TimeUpdate {
    fn get_packet_id() -> i32 {
        68
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::TimeUpdate(TimeUpdate {
            world_age: read_i64(r)?,
            time_of_day: read_i64(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&TimeUpdate::get_packet_id(), &mut ret)?;
        write_i64(&self.world_age, &mut ret)?;
        write_i64(&self.time_of_day, &mut ret)?;

        Ok(ret)
    }
    pub fn new(world_age: i64, time_of_day: i64) -> ClientboundPacket {
        ClientboundPacket::TimeUpdate(TimeUpdate {
            world_age: world_age,
            time_of_day: time_of_day,
        })
    }
    /// Get the world's age in ticks
    pub fn get_world_age(&self) -> &i64 {
        &self.world_age
    }    /// Get the current time in ticks (0 is sunrise, 6000 is noon, ...)
    pub fn get_time_of_day(&self) -> &i64 {
        &self.time_of_day
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Title {
    action: i32,
    text: Option<String>,
    times: Option<(i32, i32, i32)>,
}

impl Title {
    fn get_packet_id() -> i32 {
        69
    }


    pub fn new_raw(action: i32, text: Option<String>, times: Option<(i32, i32, i32)>) -> ClientboundPacket {
        ClientboundPacket::Title(Title {
            action: action,
            text: text,
            times: times,
        })
    }
    /// Get the raw action enum integer
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get the title/subtitle/action bar text if action is set title/subtitle/action bar in raw json
    pub fn get_text(&self) -> &Option<String> {
        &self.text
    }    /// If action is 'set times and display' get `Some((fade_in, stay, fade_out))` else get `None`
    pub fn get_times(&self) -> &Option<(i32, i32, i32)> {
        &self.times
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SoundEffect {
    sound_id: i32,
    sound_category: i32,
    x: i32,
    y: i32,
    z: i32,
    volume: f32,
    pitch: f32,
}

impl SoundEffect {
    fn get_packet_id() -> i32 {
        70
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SoundEffect(SoundEffect {
            sound_id: read_varint(r)?,
            sound_category: read_varint(r)?,
            x: read_i32(r)?,
            y: read_i32(r)?,
            z: read_i32(r)?,
            volume: read_f32(r)?,
            pitch: read_f32(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&SoundEffect::get_packet_id(), &mut ret)?;
        write_varint(&self.sound_id, &mut ret)?;
        write_varint(&self.sound_category, &mut ret)?;
        write_i32(&self.x, &mut ret)?;
        write_i32(&self.y, &mut ret)?;
        write_i32(&self.z, &mut ret)?;
        write_f32(&self.volume, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(sound_id: i32, sound_category: i32, x: i32, y: i32, z: i32, volume: f32, pitch: f32) -> ClientboundPacket {
        ClientboundPacket::SoundEffect(SoundEffect {
            sound_id: sound_id,
            sound_category: sound_category,
            x: x,
            y: y,
            z: z,
            volume: volume,
            pitch: pitch,
        })
    }
    /// Get the raw sound effect ID. Note that the meaning of this is liable to change between MC releases.
    pub fn get_sound_id(&self) -> &i32 {
        &self.sound_id
    }    /// Get the raw sound category ID.
    pub fn get_sound_category(&self) -> &i32 {
        &self.sound_category
    }    /// Get the X effect multiplied by 8
    pub fn get_x(&self) -> &i32 {
        &self.x
    }    /// Get the Y effect multiplied by 8
    pub fn get_y(&self) -> &i32 {
        &self.y
    }    /// Get the Z effect multiplied by 8
    pub fn get_z(&self) -> &i32 {
        &self.z
    }    /// Get the volume where 1.0 is 100%
    pub fn get_volume(&self) -> &f32 {
        &self.volume
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerListHeaderFooter {
    header: String,
    footer: String,
}

impl PlayerListHeaderFooter {
    fn get_packet_id() -> i32 {
        71
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerListHeaderFooter(PlayerListHeaderFooter {
            header: read_String(r)?,
            footer: read_String(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&PlayerListHeaderFooter::get_packet_id(), &mut ret)?;
        write_String(&self.header, &mut ret)?;
        write_String(&self.footer, &mut ret)?;

        Ok(ret)
    }
    pub fn new(header: String, footer: String) -> ClientboundPacket {
        ClientboundPacket::PlayerListHeaderFooter(PlayerListHeaderFooter {
            header: header,
            footer: footer,
        })
    }
    /// Get the raw json data for the header
    pub fn get_header(&self) -> &String {
        &self.header
    }    /// Get the raw json data for the footer
    pub fn get_footer(&self) -> &String {
        &self.footer
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CollectItem {
    collected_entity_id: i32,
    collector_entity_id: i32,
    item_count: i32,
}

impl CollectItem {
    fn get_packet_id() -> i32 {
        72
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::CollectItem(CollectItem {
            collected_entity_id: read_varint(r)?,
            collector_entity_id: read_varint(r)?,
            item_count: read_varint(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&CollectItem::get_packet_id(), &mut ret)?;
        write_varint(&self.collected_entity_id, &mut ret)?;
        write_varint(&self.collector_entity_id, &mut ret)?;
        write_varint(&self.item_count, &mut ret)?;

        Ok(ret)
    }
    pub fn new(collected_entity_id: i32, collector_entity_id: i32, item_count: i32) -> ClientboundPacket {
        ClientboundPacket::CollectItem(CollectItem {
            collected_entity_id: collected_entity_id,
            collector_entity_id: collector_entity_id,
            item_count: item_count,
        })
    }
    /// Get the entity ID of the collected item
    pub fn get_collected_entity_id(&self) -> &i32 {
        &self.collected_entity_id
    }    /// Get the entity ID of the person picking up the item
    pub fn get_collector_entity_id(&self) -> &i32 {
        &self.collector_entity_id
    }    /// Get how many items were picked up
    pub fn get_item_count(&self) -> &i32 {
        &self.item_count
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityTeleport {
    entity_id: i32,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityTeleport {
    fn get_packet_id() -> i32 {
        73
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityTeleport(EntityTeleport {
            entity_id: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityTeleport::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_i8(&self.yaw, &mut ret)?;
        write_i8(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, x: f64, y: f64, z: f64, yaw: i8, pitch: i8, on_ground: bool) -> ClientboundPacket {
        ClientboundPacket::EntityTeleport(EntityTeleport {
            entity_id: entity_id,
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the entity ID of the entity teleported
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the X coordinate the entity moved to
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate the entity moved to
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate the entity moved to
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the (absolute) yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }    /// Get whether the entity is now on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityProperties {
    entity_id: i32,
    data: Vec<u8>,
}

impl EntityProperties {
    fn get_packet_id() -> i32 {
        74
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityProperties(EntityProperties {
            entity_id: read_varint(r)?,
            data: read_bytearray_to_end(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityProperties::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, data: Vec<u8>) -> ClientboundPacket {
        ClientboundPacket::EntityProperties(EntityProperties {
            entity_id: entity_id,
            data: data,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw data for this packet. This library does not attempt to parse the packet
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityEffect {
    entity_id: i32,
    effect_id: u8,
    amplifier: i8,
    duration: i32,
    flags: u8,
}

impl EntityEffect {
    fn get_packet_id() -> i32 {
        75
    }
    fn deserialize<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityEffect(EntityEffect {
            entity_id: read_varint(r)?,
            effect_id: read_u8(r)?,
            amplifier: read_i8(r)?,
            duration: read_varint(r)?,
            flags: read_u8(r)?,

        }))
    }
    fn to_u8(&self) -> io::Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&EntityEffect::get_packet_id(), &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_u8(&self.effect_id, &mut ret)?;
        write_i8(&self.amplifier, &mut ret)?;
        write_varint(&self.duration, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, effect_id: u8, amplifier: i8, duration: i32, flags: u8) -> ClientboundPacket {
        ClientboundPacket::EntityEffect(EntityEffect {
            entity_id: entity_id,
            effect_id: effect_id,
            amplifier: amplifier,
            duration: duration,
            flags: flags,
        })
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the raw effect ID integer enum
    pub fn get_effect_id(&self) -> &u8 {
        &self.effect_id
    }    /// Get the amplifier = effect level - 1
    pub fn get_amplifier(&self) -> &i8 {
        &self.amplifier
    }    /// Get the duration of the effect in seconds
    pub fn get_duration(&self) -> &i32 {
        &self.duration
    }    /// Get the raw flags byte
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }
}

