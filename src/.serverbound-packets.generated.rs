/* This file is automatically generated by packets.clj
Do not manually edit this file, if you wish to make
changes here, then edit and rerun packets.clj */

#[derive(Debug, PartialEq, Clone)]
pub struct Handshake {
    protocol_version: i32,
    server_address: String,
    server_port: u16,
    next_state: i32,
}

impl Handshake {
    const PACKET_ID: i32 = 0;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Handshake(Handshake {
            protocol_version: read_varint(r).chain_err(|| "while reading field protocol_version")?,
            server_address: read_String(r).chain_err(|| "while reading field server_address")?,
            server_port: read_u16(r).chain_err(|| "while reading field server_port")?,
            next_state: read_varint(r).chain_err(|| "while reading field next_state")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.protocol_version, &mut ret)?;
        write_String(&self.server_address, &mut ret)?;
        write_u16(&self.server_port, &mut ret)?;
        write_varint(&self.next_state, &mut ret)?;

        Ok(ret)
    }
    pub fn new(protocol_version: i32, server_address: String, server_port: u16, next_state: i32) -> ServerboundPacket {
        ServerboundPacket::Handshake(Handshake {
            protocol_version: protocol_version,
            server_address: server_address,
            server_port: server_port,
            next_state: next_state,
        })
    }
    /// Get the client's protocol version
    pub fn get_protocol_version(&self) -> &i32 {
        &self.protocol_version
    }    /// Get the hostname of the server the client connected to
    pub fn get_server_address(&self) -> &String {
        &self.server_address
    }    /// Get the port of the server the client connected to
    pub fn get_server_port(&self) -> &u16 {
        &self.server_port
    }    /// Get the next state
    pub fn get_next_state(&self) -> &i32 {
        &self.next_state
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusRequest {
}

impl StatusRequest {
    const PACKET_ID: i32 = 0;


    pub fn new_raw() -> ServerboundPacket {
        ServerboundPacket::StatusRequest(StatusRequest {
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusPing {
    id: u64,
}

impl StatusPing {
    const PACKET_ID: i32 = 1;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::StatusPing(StatusPing {
            id: read_u64(r).chain_err(|| "while reading field id")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: u64) -> ServerboundPacket {
        ServerboundPacket::StatusPing(StatusPing {
            id: id,
        })
    }
    /// Get the id
    pub fn get_id(&self) -> &u64 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginStart {
    name: String,
}

impl LoginStart {
    const PACKET_ID: i32 = 0;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::LoginStart(LoginStart {
            name: read_String(r).chain_err(|| "while reading field name")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.name, &mut ret)?;

        Ok(ret)
    }
    pub fn new(name: String) -> ServerboundPacket {
        ServerboundPacket::LoginStart(LoginStart {
            name: name,
        })
    }
    /// Get the player's claimed username
    pub fn get_name(&self) -> &String {
        &self.name
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EncryptionResponse {
    shared_secret: Vec<u8>,
    verify_token: Vec<u8>,
}

impl EncryptionResponse {
    const PACKET_ID: i32 = 1;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::EncryptionResponse(EncryptionResponse {
            shared_secret: read_prefixed_bytearray(r).chain_err(|| "while reading field shared_secret")?,
            verify_token: read_prefixed_bytearray(r).chain_err(|| "while reading field verify_token")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_prefixed_bytearray(&self.shared_secret, &mut ret)?;
        write_prefixed_bytearray(&self.verify_token, &mut ret)?;

        Ok(ret)
    }
    pub fn new(shared_secret: Vec<u8>, verify_token: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::EncryptionResponse(EncryptionResponse {
            shared_secret: shared_secret,
            verify_token: verify_token,
        })
    }
    /// Get the (raw encrypted) shared secret
    pub fn get_shared_secret(&self) -> &Vec<u8> {
        &self.shared_secret
    }    /// Get the (raw encrypted) verify token
    pub fn get_verify_token(&self) -> &Vec<u8> {
        &self.verify_token
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginPluginResponse {
    message_id: i32,
    successful: bool,
    data: Vec<u8>,
}

impl LoginPluginResponse {
    const PACKET_ID: i32 = 2;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::LoginPluginResponse(LoginPluginResponse {
            message_id: read_varint(r).chain_err(|| "while reading field message_id")?,
            successful: read_bool(r).chain_err(|| "while reading field successful")?,
            data: read_bytearray_to_end(r).chain_err(|| "while reading field data")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.message_id, &mut ret)?;
        write_bool(&self.successful, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(message_id: i32, successful: bool, data: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::LoginPluginResponse(LoginPluginResponse {
            message_id: message_id,
            successful: successful,
            data: data,
        })
    }
    /// Get the message ID
    pub fn get_message_id(&self) -> &i32 {
        &self.message_id
    }    /// Get whether the client understood the request. If false, the data vector will be empty
    pub fn get_successful(&self) -> &bool {
        &self.successful
    }    /// Get the data
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct TeleportConfirm {
    id: i32,
}

impl TeleportConfirm {
    const PACKET_ID: i32 = 0;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::TeleportConfirm(TeleportConfirm {
            id: read_varint(r).chain_err(|| "while reading field id")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i32) -> ServerboundPacket {
        ServerboundPacket::TeleportConfirm(TeleportConfirm {
            id: id,
        })
    }
    /// Get the teleport id
    pub fn get_id(&self) -> &i32 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct QueryBlockNBT {
    transaction_id: i32,
    location: (i32, i32, i32),
}

impl QueryBlockNBT {
    const PACKET_ID: i32 = 1;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::QueryBlockNBT(QueryBlockNBT {
            transaction_id: read_varint(r).chain_err(|| "while reading field transaction_id")?,
            location: read_position(r).chain_err(|| "while reading field location")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.transaction_id, &mut ret)?;
        write_position(&self.location, &mut ret)?;

        Ok(ret)
    }
    pub fn new(transaction_id: i32, location: (i32, i32, i32)) -> ServerboundPacket {
        ServerboundPacket::QueryBlockNBT(QueryBlockNBT {
            transaction_id: transaction_id,
            location: location,
        })
    }
    /// Get the transaction ID
    pub fn get_transaction_id(&self) -> &i32 {
        &self.transaction_id
    }    /// Get the X/Y/Z coords position
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetDifficulty {
    new_difficulty: u8,
}

impl SetDifficulty {
    const PACKET_ID: i32 = 2;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::SetDifficulty(SetDifficulty {
            new_difficulty: read_u8(r).chain_err(|| "while reading field new_difficulty")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.new_difficulty, &mut ret)?;

        Ok(ret)
    }
    pub fn new(new_difficulty: u8) -> ServerboundPacket {
        ServerboundPacket::SetDifficulty(SetDifficulty {
            new_difficulty: new_difficulty,
        })
    }
    /// Get the new difficulty
    pub fn get_new_difficulty(&self) -> &u8 {
        &self.new_difficulty
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChatMessage {
    message: String,
}

impl ChatMessage {
    const PACKET_ID: i32 = 3;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ChatMessage(ChatMessage {
            message: read_String(r).chain_err(|| "while reading field message")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.message, &mut ret)?;

        Ok(ret)
    }
    pub fn new(message: String) -> ServerboundPacket {
        ServerboundPacket::ChatMessage(ChatMessage {
            message: message,
        })
    }
    /// Get the chat message (not json)
    pub fn get_message(&self) -> &String {
        &self.message
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientStatus {
    action: i32,
}

impl ClientStatus {
    const PACKET_ID: i32 = 4;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClientStatus(ClientStatus {
            action: read_varint(r).chain_err(|| "while reading field action")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.action, &mut ret)?;

        Ok(ret)
    }
    pub fn new(action: i32) -> ServerboundPacket {
        ServerboundPacket::ClientStatus(ClientStatus {
            action: action,
        })
    }
    /// Get the action ID varint enum
    pub fn get_action(&self) -> &i32 {
        &self.action
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientSettings {
    locale: String,
    view_distance: u8,
    chat_mode: i32,
    chat_colors: bool,
    displayed_skin_parts: u8,
    main_hand: i32,
}

impl ClientSettings {
    const PACKET_ID: i32 = 5;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClientSettings(ClientSettings {
            locale: read_String(r).chain_err(|| "while reading field locale")?,
            view_distance: read_u8(r).chain_err(|| "while reading field view_distance")?,
            chat_mode: read_varint(r).chain_err(|| "while reading field chat_mode")?,
            chat_colors: read_bool(r).chain_err(|| "while reading field chat_colors")?,
            displayed_skin_parts: read_u8(r).chain_err(|| "while reading field displayed_skin_parts")?,
            main_hand: read_varint(r).chain_err(|| "while reading field main_hand")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.locale, &mut ret)?;
        write_u8(&self.view_distance, &mut ret)?;
        write_varint(&self.chat_mode, &mut ret)?;
        write_bool(&self.chat_colors, &mut ret)?;
        write_u8(&self.displayed_skin_parts, &mut ret)?;
        write_varint(&self.main_hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(locale: String, view_distance: u8, chat_mode: i32, chat_colors: bool, displayed_skin_parts: u8, main_hand: i32) -> ServerboundPacket {
        ServerboundPacket::ClientSettings(ClientSettings {
            locale: locale,
            view_distance: view_distance,
            chat_mode: chat_mode,
            chat_colors: chat_colors,
            displayed_skin_parts: displayed_skin_parts,
            main_hand: main_hand,
        })
    }
    /// Get the client's locale
    pub fn get_locale(&self) -> &String {
        &self.locale
    }    /// Get the client's view distance in chunks
    pub fn get_view_distance(&self) -> &u8 {
        &self.view_distance
    }    /// Get the client's chat mode as varint enum
    pub fn get_chat_mode(&self) -> &i32 {
        &self.chat_mode
    }    /// Get whether the player has chat colors enabled
    pub fn get_chat_colors(&self) -> &bool {
        &self.chat_colors
    }    /// Get the displayed skin parts as a raw bit mask
    pub fn get_displayed_skin_parts(&self) -> &u8 {
        &self.displayed_skin_parts
    }    /// Get the player's main hand as a varint enum
    pub fn get_main_hand(&self) -> &i32 {
        &self.main_hand
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct TabComplete {
    transaction_id: i32,
    text: String,
}

impl TabComplete {
    const PACKET_ID: i32 = 6;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::TabComplete(TabComplete {
            transaction_id: read_varint(r).chain_err(|| "while reading field transaction_id")?,
            text: read_String(r).chain_err(|| "while reading field text")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.transaction_id, &mut ret)?;
        write_String(&self.text, &mut ret)?;

        Ok(ret)
    }
    pub fn new(transaction_id: i32, text: String) -> ServerboundPacket {
        ServerboundPacket::TabComplete(TabComplete {
            transaction_id: transaction_id,
            text: text,
        })
    }
    /// Get the transaction ID
    pub fn get_transaction_id(&self) -> &i32 {
        &self.transaction_id
    }    /// Get the text behind the cursor
    pub fn get_text(&self) -> &String {
        &self.text
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ConfirmTransaction {
    window_id: u8,
    id: i16,
    accepted: bool,
}

impl ConfirmTransaction {
    const PACKET_ID: i32 = 7;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ConfirmTransaction(ConfirmTransaction {
            window_id: read_u8(r).chain_err(|| "while reading field window_id")?,
            id: read_i16(r).chain_err(|| "while reading field id")?,
            accepted: read_bool(r).chain_err(|| "while reading field accepted")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.id, &mut ret)?;
        write_bool(&self.accepted, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, id: i16, accepted: bool) -> ServerboundPacket {
        ServerboundPacket::ConfirmTransaction(ConfirmTransaction {
            window_id: window_id,
            id: id,
            accepted: accepted,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the action number
    pub fn get_id(&self) -> &i16 {
        &self.id
    }    /// Get whether the action was accepted
    pub fn get_accepted(&self) -> &bool {
        &self.accepted
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EnchantItem {
    window_id: u8,
    enchantment: i8,
}

impl EnchantItem {
    const PACKET_ID: i32 = 8;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::EnchantItem(EnchantItem {
            window_id: read_u8(r).chain_err(|| "while reading field window_id")?,
            enchantment: read_i8(r).chain_err(|| "while reading field enchantment")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i8(&self.enchantment, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, enchantment: i8) -> ServerboundPacket {
        ServerboundPacket::EnchantItem(EnchantItem {
            window_id: window_id,
            enchantment: enchantment,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the position of the chosen enchantment
    pub fn get_enchantment(&self) -> &i8 {
        &self.enchantment
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClickWindow {
    window_id: u8,
    slot_id: i16,
    button: i8,
    id: i16,
    mode: i32,
    slot: Vec<u8>,
}

impl ClickWindow {
    const PACKET_ID: i32 = 9;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClickWindow(ClickWindow {
            window_id: read_u8(r).chain_err(|| "while reading field window_id")?,
            slot_id: read_i16(r).chain_err(|| "while reading field slot_id")?,
            button: read_i8(r).chain_err(|| "while reading field button")?,
            id: read_i16(r).chain_err(|| "while reading field id")?,
            mode: read_varint(r).chain_err(|| "while reading field mode")?,
            slot: read_bytearray(r).chain_err(|| "while reading field slot")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_i8(&self.button, &mut ret)?;
        write_i16(&self.id, &mut ret)?;
        write_varint(&self.mode, &mut ret)?;
        write_bytearray(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, slot_id: i16, button: i8, id: i16, mode: i32, slot: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::ClickWindow(ClickWindow {
            window_id: window_id,
            slot_id: slot_id,
            button: button,
            id: id,
            mode: mode,
            slot: slot,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the clicked slot number
    pub fn get_slot_id(&self) -> &i16 {
        &self.slot_id
    }    /// Get the button clicked byte enum
    pub fn get_button(&self) -> &i8 {
        &self.button
    }    /// Get the action number id
    pub fn get_id(&self) -> &i16 {
        &self.id
    }    /// Get the action/mode
    pub fn get_mode(&self) -> &i32 {
        &self.mode
    }    /// Get the raw unprocessed slot data
    pub fn get_slot(&self) -> &Vec<u8> {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CloseWindow {
    window_id: u8,
}

impl CloseWindow {
    const PACKET_ID: i32 = 10;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::CloseWindow(CloseWindow {
            window_id: read_u8(r).chain_err(|| "while reading field window_id")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8) -> ServerboundPacket {
        ServerboundPacket::CloseWindow(CloseWindow {
            window_id: window_id,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PluginMessage {
    channel: String,
    data: Vec<u8>,
}

impl PluginMessage {
    const PACKET_ID: i32 = 11;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PluginMessage(PluginMessage {
            channel: read_String(r).chain_err(|| "while reading field channel")?,
            data: read_bytearray(r).chain_err(|| "while reading field data")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.channel, &mut ret)?;
        write_bytearray(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(channel: String, data: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::PluginMessage(PluginMessage {
            channel: channel,
            data: data,
        })
    }
    /// Get the channel
    pub fn get_channel(&self) -> &String {
        &self.channel
    }    /// Get the data
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EditBook {
    data: Vec<u8>,
}

impl EditBook {
    const PACKET_ID: i32 = 12;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::EditBook(EditBook {
            data: read_bytearray_to_end(r).chain_err(|| "while reading field data")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bytearray_to_end(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(data: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::EditBook(EditBook {
            data: data,
        })
    }
    /// Get the raw data contained in this packet. The first field in the packet is NBT slot data, and therefore we cannot parse the remaining data without parsing the NBT.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct QueryEntityNBT {
    transaction_id: i32,
    entity_id: i32,
}

impl QueryEntityNBT {
    const PACKET_ID: i32 = 13;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::QueryEntityNBT(QueryEntityNBT {
            transaction_id: read_varint(r).chain_err(|| "while reading field transaction_id")?,
            entity_id: read_varint(r).chain_err(|| "while reading field entity_id")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.transaction_id, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(transaction_id: i32, entity_id: i32) -> ServerboundPacket {
        ServerboundPacket::QueryEntityNBT(QueryEntityNBT {
            transaction_id: transaction_id,
            entity_id: entity_id,
        })
    }
    /// Get the transaction ID
    pub fn get_transaction_id(&self) -> &i32 {
        &self.transaction_id
    }    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UseEntity {
    target: i32,
    action: i32,
    location: Option<(f32, f32, f32)>,
    hand: Option<i32>,
}

impl UseEntity {
    const PACKET_ID: i32 = 14;


    pub fn new_raw(target: i32, action: i32, location: Option<(f32, f32, f32)>, hand: Option<i32>) -> ServerboundPacket {
        ServerboundPacket::UseEntity(UseEntity {
            target: target,
            action: action,
            location: location,
            hand: hand,
        })
    }
    /// Get the target eid
    pub fn get_target(&self) -> &i32 {
        &self.target
    }    /// Get the action type varint enum
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get the target location (if any)
    pub fn get_location(&self) -> &Option<(f32, f32, f32)> {
        &self.location
    }    /// Get the hand used as a varint enum (if any)
    pub fn get_hand(&self) -> &Option<i32> {
        &self.hand
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct KeepAlive {
    id: i64,
}

impl KeepAlive {
    const PACKET_ID: i32 = 15;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::KeepAlive(KeepAlive {
            id: read_i64(r).chain_err(|| "while reading field id")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i64) -> ServerboundPacket {
        ServerboundPacket::KeepAlive(KeepAlive {
            id: id,
        })
    }
    /// Get the keep alive ID
    pub fn get_id(&self) -> &i64 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LockDifficulty {
    locked: bool,
}

impl LockDifficulty {
    const PACKET_ID: i32 = 16;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::LockDifficulty(LockDifficulty {
            locked: read_bool(r).chain_err(|| "while reading field locked")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bool(&self.locked, &mut ret)?;

        Ok(ret)
    }
    pub fn new(locked: bool) -> ServerboundPacket {
        ServerboundPacket::LockDifficulty(LockDifficulty {
            locked: locked,
        })
    }
    /// Get whether or not the difficulty is locked
    pub fn get_locked(&self) -> &bool {
        &self.locked
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPosition {
    x: f64,
    y: f64,
    z: f64,
    on_ground: bool,
}

impl PlayerPosition {
    const PACKET_ID: i32 = 17;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerPosition(PlayerPosition {
            x: read_f64(r).chain_err(|| "while reading field x")?,
            y: read_f64(r).chain_err(|| "while reading field y")?,
            z: read_f64(r).chain_err(|| "while reading field z")?,
            on_ground: read_bool(r).chain_err(|| "while reading field on_ground")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerPosition(PlayerPosition {
            x: x,
            y: y,
            z: z,
            on_ground: on_ground,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate (feet)
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPositionAndLook {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
    on_ground: bool,
}

impl PlayerPositionAndLook {
    const PACKET_ID: i32 = 18;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: read_f64(r).chain_err(|| "while reading field x")?,
            y: read_f64(r).chain_err(|| "while reading field y")?,
            z: read_f64(r).chain_err(|| "while reading field z")?,
            yaw: read_f32(r).chain_err(|| "while reading field yaw")?,
            pitch: read_f32(r).chain_err(|| "while reading field pitch")?,
            on_ground: read_bool(r).chain_err(|| "while reading field on_ground")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerLook {
    yaw: f32,
    pitch: f32,
    on_ground: bool,
}

impl PlayerLook {
    const PACKET_ID: i32 = 19;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerLook(PlayerLook {
            yaw: read_f32(r).chain_err(|| "while reading field yaw")?,
            pitch: read_f32(r).chain_err(|| "while reading field pitch")?,
            on_ground: read_bool(r).chain_err(|| "while reading field on_ground")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(yaw: f32, pitch: f32, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerLook(PlayerLook {
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Player {
    on_ground: bool,
}

impl Player {
    const PACKET_ID: i32 = 20;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Player(Player {
            on_ground: read_bool(r).chain_err(|| "while reading field on_ground")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::Player(Player {
            on_ground: on_ground,
        })
    }
    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct VehicleMove {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
}

impl VehicleMove {
    const PACKET_ID: i32 = 21;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::VehicleMove(VehicleMove {
            x: read_f64(r).chain_err(|| "while reading field x")?,
            y: read_f64(r).chain_err(|| "while reading field y")?,
            z: read_f64(r).chain_err(|| "while reading field z")?,
            yaw: read_f32(r).chain_err(|| "while reading field yaw")?,
            pitch: read_f32(r).chain_err(|| "while reading field pitch")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32) -> ServerboundPacket {
        ServerboundPacket::VehicleMove(VehicleMove {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
        })
    }
    /// Get the (absolute) X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the (absolute) Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the (absolute) Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the (absolute) yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SteerBoat {
    right: bool,
    left: bool,
}

impl SteerBoat {
    const PACKET_ID: i32 = 22;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::SteerBoat(SteerBoat {
            right: read_bool(r).chain_err(|| "while reading field right")?,
            left: read_bool(r).chain_err(|| "while reading field left")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bool(&self.right, &mut ret)?;
        write_bool(&self.left, &mut ret)?;

        Ok(ret)
    }
    pub fn new(right: bool, left: bool) -> ServerboundPacket {
        ServerboundPacket::SteerBoat(SteerBoat {
            right: right,
            left: left,
        })
    }
    /// Get whether the right paddle is turning
    pub fn get_right(&self) -> &bool {
        &self.right
    }    /// Get whether the left paddle is turning
    pub fn get_left(&self) -> &bool {
        &self.left
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PickItem {
    slot_to_use: i32,
}

impl PickItem {
    const PACKET_ID: i32 = 23;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PickItem(PickItem {
            slot_to_use: read_varint(r).chain_err(|| "while reading field slot_to_use")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.slot_to_use, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot_to_use: i32) -> ServerboundPacket {
        ServerboundPacket::PickItem(PickItem {
            slot_to_use: slot_to_use,
        })
    }
    /// Get the slot to use
    pub fn get_slot_to_use(&self) -> &i32 {
        &self.slot_to_use
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CraftRecipeRequest {
    window_id: u8,
    recipe: i32,
    make_all: bool,
}

impl CraftRecipeRequest {
    const PACKET_ID: i32 = 24;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::CraftRecipeRequest(CraftRecipeRequest {
            window_id: read_u8(r).chain_err(|| "while reading field window_id")?,
            recipe: read_varint(r).chain_err(|| "while reading field recipe")?,
            make_all: read_bool(r).chain_err(|| "while reading field make_all")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_varint(&self.recipe, &mut ret)?;
        write_bool(&self.make_all, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, recipe: i32, make_all: bool) -> ServerboundPacket {
        ServerboundPacket::CraftRecipeRequest(CraftRecipeRequest {
            window_id: window_id,
            recipe: recipe,
            make_all: make_all,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the recipe ID
    pub fn get_recipe(&self) -> &i32 {
        &self.recipe
    }    /// Get if shift was down when the item was clicked
    pub fn get_make_all(&self) -> &bool {
        &self.make_all
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerAbilities {
    flags: u8,
    flying_speed: f32,
    walking_speed: f32,
}

impl PlayerAbilities {
    const PACKET_ID: i32 = 25;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerAbilities(PlayerAbilities {
            flags: read_u8(r).chain_err(|| "while reading field flags")?,
            flying_speed: read_f32(r).chain_err(|| "while reading field flying_speed")?,
            walking_speed: read_f32(r).chain_err(|| "while reading field walking_speed")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;
        write_f32(&self.flying_speed, &mut ret)?;
        write_f32(&self.walking_speed, &mut ret)?;

        Ok(ret)
    }
    pub fn new(flags: u8, flying_speed: f32, walking_speed: f32) -> ServerboundPacket {
        ServerboundPacket::PlayerAbilities(PlayerAbilities {
            flags: flags,
            flying_speed: flying_speed,
            walking_speed: walking_speed,
        })
    }
    /// Get the raw player abilities bit mask
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }    /// Get the player's flying speed
    pub fn get_flying_speed(&self) -> &f32 {
        &self.flying_speed
    }    /// Get the player's walking speed
    pub fn get_walking_speed(&self) -> &f32 {
        &self.walking_speed
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerDigging {
    status: i32,
    location: (i32, i32, i32),
    face: u8,
}

impl PlayerDigging {
    const PACKET_ID: i32 = 26;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerDigging(PlayerDigging {
            status: read_varint(r).chain_err(|| "while reading field status")?,
            location: read_position(r).chain_err(|| "while reading field location")?,
            face: read_u8(r).chain_err(|| "while reading field face")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.status, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_u8(&self.face, &mut ret)?;

        Ok(ret)
    }
    pub fn new(status: i32, location: (i32, i32, i32), face: u8) -> ServerboundPacket {
        ServerboundPacket::PlayerDigging(PlayerDigging {
            status: status,
            location: location,
            face: face,
        })
    }
    /// Get the status as a raw varint enum
    pub fn get_status(&self) -> &i32 {
        &self.status
    }    /// Get the location of the block
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the face of the block being hit as a raw byte enum
    pub fn get_face(&self) -> &u8 {
        &self.face
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityAction {
    entity_id: i32,
    action: i32,
    jump_boost: i32,
}

impl EntityAction {
    const PACKET_ID: i32 = 27;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::EntityAction(EntityAction {
            entity_id: read_varint(r).chain_err(|| "while reading field entity_id")?,
            action: read_varint(r).chain_err(|| "while reading field action")?,
            jump_boost: read_varint(r).chain_err(|| "while reading field jump_boost")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_varint(&self.action, &mut ret)?;
        write_varint(&self.jump_boost, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, action: i32, jump_boost: i32) -> ServerboundPacket {
        ServerboundPacket::EntityAction(EntityAction {
            entity_id: entity_id,
            action: action,
            jump_boost: jump_boost,
        })
    }
    /// Get the player's eid
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the action as a raw varint enum
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get the jump boost, used if the player is riding a horse
    pub fn get_jump_boost(&self) -> &i32 {
        &self.jump_boost
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SteerVehicle {
    sideways: f32,
    forward: f32,
    flags: u8,
}

impl SteerVehicle {
    const PACKET_ID: i32 = 28;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::SteerVehicle(SteerVehicle {
            sideways: read_f32(r).chain_err(|| "while reading field sideways")?,
            forward: read_f32(r).chain_err(|| "while reading field forward")?,
            flags: read_u8(r).chain_err(|| "while reading field flags")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f32(&self.sideways, &mut ret)?;
        write_f32(&self.forward, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;

        Ok(ret)
    }
    pub fn new(sideways: f32, forward: f32, flags: u8) -> ServerboundPacket {
        ServerboundPacket::SteerVehicle(SteerVehicle {
            sideways: sideways,
            forward: forward,
            flags: flags,
        })
    }
    /// Get the sideways movement, positiev is to the left of the player
    pub fn get_sideways(&self) -> &f32 {
        &self.sideways
    }    /// Get the forward movement
    pub fn get_forward(&self) -> &f32 {
        &self.forward
    }    /// Get the raw flags byte enum
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct RecipeBookData {
    displayed_recipe: Option<String>,
    recipe_book_states: Option<(bool, bool, bool, bool)>,
}

impl RecipeBookData {
    const PACKET_ID: i32 = 29;


    pub fn new_raw(displayed_recipe: Option<String>, recipe_book_states: Option<(bool, bool, bool, bool)>) -> ServerboundPacket {
        ServerboundPacket::RecipeBookData(RecipeBookData {
            displayed_recipe: displayed_recipe,
            recipe_book_states: recipe_book_states,
        })
    }
    /// Get the displayed recipe if packet is type 0
    pub fn get_displayed_recipe(&self) -> &Option<String> {
        &self.displayed_recipe
    }    /// Get whether crafting recipe book is open, crafting recipe filter is active, smelting recipe book is open, and smelting recipe filter is active if packet is type 1.
    pub fn get_recipe_book_states(&self) -> &Option<(bool, bool, bool, bool)> {
        &self.recipe_book_states
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct NameItem {
    name: String,
}

impl NameItem {
    const PACKET_ID: i32 = 30;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::NameItem(NameItem {
            name: read_String(r).chain_err(|| "while reading field name")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.name, &mut ret)?;

        Ok(ret)
    }
    pub fn new(name: String) -> ServerboundPacket {
        ServerboundPacket::NameItem(NameItem {
            name: name,
        })
    }
    /// Get the new name of the item
    pub fn get_name(&self) -> &String {
        &self.name
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ResourcePackStatus {
    result: i32,
}

impl ResourcePackStatus {
    const PACKET_ID: i32 = 31;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ResourcePackStatus(ResourcePackStatus {
            result: read_varint(r).chain_err(|| "while reading field result")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.result, &mut ret)?;

        Ok(ret)
    }
    pub fn new(result: i32) -> ServerboundPacket {
        ServerboundPacket::ResourcePackStatus(ResourcePackStatus {
            result: result,
        })
    }
    /// Get the result as a raw varint enum
    pub fn get_result(&self) -> &i32 {
        &self.result
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct AdvancementTab {
    tab_id: Option<String>,
}

impl AdvancementTab {
    const PACKET_ID: i32 = 32;


    pub fn new_raw(tab_id: Option<String>) -> ServerboundPacket {
        ServerboundPacket::AdvancementTab(AdvancementTab {
            tab_id: tab_id,
        })
    }
    /// Get Some(Tab ID) if the action was to open a tab, and None else
    pub fn get_tab_id(&self) -> &Option<String> {
        &self.tab_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SelectTrade {
    selected_slot: i32,
}

impl SelectTrade {
    const PACKET_ID: i32 = 33;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::SelectTrade(SelectTrade {
            selected_slot: read_varint(r).chain_err(|| "while reading field selected_slot")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.selected_slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(selected_slot: i32) -> ServerboundPacket {
        ServerboundPacket::SelectTrade(SelectTrade {
            selected_slot: selected_slot,
        })
    }
    /// Get the selected slot in the players inventory.
    pub fn get_selected_slot(&self) -> &i32 {
        &self.selected_slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetBeaconEffect {
    primary_effect: i32,
    secondary_effect: i32,
}

impl SetBeaconEffect {
    const PACKET_ID: i32 = 34;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::SetBeaconEffect(SetBeaconEffect {
            primary_effect: read_varint(r).chain_err(|| "while reading field primary_effect")?,
            secondary_effect: read_varint(r).chain_err(|| "while reading field secondary_effect")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.primary_effect, &mut ret)?;
        write_varint(&self.secondary_effect, &mut ret)?;

        Ok(ret)
    }
    pub fn new(primary_effect: i32, secondary_effect: i32) -> ServerboundPacket {
        ServerboundPacket::SetBeaconEffect(SetBeaconEffect {
            primary_effect: primary_effect,
            secondary_effect: secondary_effect,
        })
    }
    /// Get the potion ID of the primary effect.
    pub fn get_primary_effect(&self) -> &i32 {
        &self.primary_effect
    }    /// Get the potion ID of the secondary effect.
    pub fn get_secondary_effect(&self) -> &i32 {
        &self.secondary_effect
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct HeldItemChange {
    slot: i16,
}

impl HeldItemChange {
    const PACKET_ID: i32 = 35;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::HeldItemChange(HeldItemChange {
            slot: read_i16(r).chain_err(|| "while reading field slot")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i16(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot: i16) -> ServerboundPacket {
        ServerboundPacket::HeldItemChange(HeldItemChange {
            slot: slot,
        })
    }
    /// Get the slot the player has selected
    pub fn get_slot(&self) -> &i16 {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateCommandBlock {
    location: (i32, i32, i32),
    command: String,
    mode: i32,
    flags: u8,
}

impl UpdateCommandBlock {
    const PACKET_ID: i32 = 36;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UpdateCommandBlock(UpdateCommandBlock {
            location: read_position(r).chain_err(|| "while reading field location")?,
            command: read_String(r).chain_err(|| "while reading field command")?,
            mode: read_varint(r).chain_err(|| "while reading field mode")?,
            flags: read_u8(r).chain_err(|| "while reading field flags")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_String(&self.command, &mut ret)?;
        write_varint(&self.mode, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), command: String, mode: i32, flags: u8) -> ServerboundPacket {
        ServerboundPacket::UpdateCommandBlock(UpdateCommandBlock {
            location: location,
            command: command,
            mode: mode,
            flags: flags,
        })
    }
    /// Get the position
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the new string
    pub fn get_command(&self) -> &String {
        &self.command
    }    /// Get the mode (enum)
    pub fn get_mode(&self) -> &i32 {
        &self.mode
    }    /// Get the bitarray of flags
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateCommandBlockMinecart {
    id: i32,
    command: String,
    track_output: bool,
}

impl UpdateCommandBlockMinecart {
    const PACKET_ID: i32 = 37;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UpdateCommandBlockMinecart(UpdateCommandBlockMinecart {
            id: read_varint(r).chain_err(|| "while reading field id")?,
            command: read_String(r).chain_err(|| "while reading field command")?,
            track_output: read_bool(r).chain_err(|| "while reading field track_output")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.id, &mut ret)?;
        write_String(&self.command, &mut ret)?;
        write_bool(&self.track_output, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i32, command: String, track_output: bool) -> ServerboundPacket {
        ServerboundPacket::UpdateCommandBlockMinecart(UpdateCommandBlockMinecart {
            id: id,
            command: command,
            track_output: track_output,
        })
    }
    /// Get the entity ID
    pub fn get_id(&self) -> &i32 {
        &self.id
    }    /// Get the new string
    pub fn get_command(&self) -> &String {
        &self.command
    }    /// Get whether to store the output of the previous command
    pub fn get_track_output(&self) -> &bool {
        &self.track_output
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CreativeInventoryAction {
    slot_id: i16,
    slot: Vec<u8>,
}

impl CreativeInventoryAction {
    const PACKET_ID: i32 = 38;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::CreativeInventoryAction(CreativeInventoryAction {
            slot_id: read_i16(r).chain_err(|| "while reading field slot_id")?,
            slot: read_bytearray(r).chain_err(|| "while reading field slot")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_bytearray(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot_id: i16, slot: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::CreativeInventoryAction(CreativeInventoryAction {
            slot_id: slot_id,
            slot: slot,
        })
    }
    /// Get the inventory slot number
    pub fn get_slot_id(&self) -> &i16 {
        &self.slot_id
    }    /// Get the raw unprocessed slot data
    pub fn get_slot(&self) -> &Vec<u8> {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateJigsawBlock {
    location: (i32, i32, i32),
    attachment_type: String,
    target_pool: String,
    final_state: String,
}

impl UpdateJigsawBlock {
    const PACKET_ID: i32 = 39;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UpdateJigsawBlock(UpdateJigsawBlock {
            location: read_position(r).chain_err(|| "while reading field location")?,
            attachment_type: read_String(r).chain_err(|| "while reading field attachment_type")?,
            target_pool: read_String(r).chain_err(|| "while reading field target_pool")?,
            final_state: read_String(r).chain_err(|| "while reading field final_state")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_String(&self.attachment_type, &mut ret)?;
        write_String(&self.target_pool, &mut ret)?;
        write_String(&self.final_state, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), attachment_type: String, target_pool: String, final_state: String) -> ServerboundPacket {
        ServerboundPacket::UpdateJigsawBlock(UpdateJigsawBlock {
            location: location,
            attachment_type: attachment_type,
            target_pool: target_pool,
            final_state: final_state,
        })
    }
    /// Get the block entity location
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the attachment type identifier
    pub fn get_attachment_type(&self) -> &String {
        &self.attachment_type
    }    /// Get the target pool identifier
    pub fn get_target_pool(&self) -> &String {
        &self.target_pool
    }    /// get the final_state field (UNDOCUMENTED)
    pub fn get_final_state(&self) -> &String {
        &self.final_state
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateStructureBlock {
    location: (i32, i32, i32),
    action: i32,
    mode: i32,
    name: String,
    offset_x: i8,
    offset_y: i8,
    offset_z: i8,
    size_x: i8,
    size_y: i8,
    size_z: i8,
    mirror: i32,
    rotation: i32,
    metadata: String,
    integrity: f32,
    seed: i64,
    flags: u8,
}

impl UpdateStructureBlock {
    const PACKET_ID: i32 = 40;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UpdateStructureBlock(UpdateStructureBlock {
            location: read_position(r).chain_err(|| "while reading field location")?,
            action: read_varint(r).chain_err(|| "while reading field action")?,
            mode: read_varint(r).chain_err(|| "while reading field mode")?,
            name: read_String(r).chain_err(|| "while reading field name")?,
            offset_x: read_i8(r).chain_err(|| "while reading field offset_x")?,
            offset_y: read_i8(r).chain_err(|| "while reading field offset_y")?,
            offset_z: read_i8(r).chain_err(|| "while reading field offset_z")?,
            size_x: read_i8(r).chain_err(|| "while reading field size_x")?,
            size_y: read_i8(r).chain_err(|| "while reading field size_y")?,
            size_z: read_i8(r).chain_err(|| "while reading field size_z")?,
            mirror: read_varint(r).chain_err(|| "while reading field mirror")?,
            rotation: read_varint(r).chain_err(|| "while reading field rotation")?,
            metadata: read_String(r).chain_err(|| "while reading field metadata")?,
            integrity: read_f32(r).chain_err(|| "while reading field integrity")?,
            seed: read_varlong(r).chain_err(|| "while reading field seed")?,
            flags: read_u8(r).chain_err(|| "while reading field flags")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_varint(&self.action, &mut ret)?;
        write_varint(&self.mode, &mut ret)?;
        write_String(&self.name, &mut ret)?;
        write_i8(&self.offset_x, &mut ret)?;
        write_i8(&self.offset_y, &mut ret)?;
        write_i8(&self.offset_z, &mut ret)?;
        write_i8(&self.size_x, &mut ret)?;
        write_i8(&self.size_y, &mut ret)?;
        write_i8(&self.size_z, &mut ret)?;
        write_varint(&self.mirror, &mut ret)?;
        write_varint(&self.rotation, &mut ret)?;
        write_String(&self.metadata, &mut ret)?;
        write_f32(&self.integrity, &mut ret)?;
        write_varlong(&self.seed, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), action: i32, mode: i32, name: String, offset_x: i8, offset_y: i8, offset_z: i8, size_x: i8, size_y: i8, size_z: i8, mirror: i32, rotation: i32, metadata: String, integrity: f32, seed: i64, flags: u8) -> ServerboundPacket {
        ServerboundPacket::UpdateStructureBlock(UpdateStructureBlock {
            location: location,
            action: action,
            mode: mode,
            name: name,
            offset_x: offset_x,
            offset_y: offset_y,
            offset_z: offset_z,
            size_x: size_x,
            size_y: size_y,
            size_z: size_z,
            mirror: mirror,
            rotation: rotation,
            metadata: metadata,
            integrity: integrity,
            seed: seed,
            flags: flags,
        })
    }
    /// Get the block entity position
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the action (enum)
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get the mode (enum)
    pub fn get_mode(&self) -> &i32 {
        &self.mode
    }    /// Get the name
    pub fn get_name(&self) -> &String {
        &self.name
    }    /// Get the X offset
    pub fn get_offset_x(&self) -> &i8 {
        &self.offset_x
    }    /// Get the Y offset
    pub fn get_offset_y(&self) -> &i8 {
        &self.offset_y
    }    /// Get the Z offset
    pub fn get_offset_z(&self) -> &i8 {
        &self.offset_z
    }    /// Get the X size
    pub fn get_size_x(&self) -> &i8 {
        &self.size_x
    }    /// Get the Y size
    pub fn get_size_y(&self) -> &i8 {
        &self.size_y
    }    /// Get the Z size
    pub fn get_size_z(&self) -> &i8 {
        &self.size_z
    }    /// Get the mirror enum
    pub fn get_mirror(&self) -> &i32 {
        &self.mirror
    }    /// Get the rotation enum
    pub fn get_rotation(&self) -> &i32 {
        &self.rotation
    }    /// Get the metadata
    pub fn get_metadata(&self) -> &String {
        &self.metadata
    }    /// Get the integrity
    pub fn get_integrity(&self) -> &f32 {
        &self.integrity
    }    /// Get the seed
    pub fn get_seed(&self) -> &i64 {
        &self.seed
    }    /// Get the flags bitarray
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateSign {
    location: (i32, i32, i32),
    line1: String,
    line2: String,
    line3: String,
    line4: String,
}

impl UpdateSign {
    const PACKET_ID: i32 = 41;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UpdateSign(UpdateSign {
            location: read_position(r).chain_err(|| "while reading field location")?,
            line1: read_String(r).chain_err(|| "while reading field line1")?,
            line2: read_String(r).chain_err(|| "while reading field line2")?,
            line3: read_String(r).chain_err(|| "while reading field line3")?,
            line4: read_String(r).chain_err(|| "while reading field line4")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_String(&self.line1, &mut ret)?;
        write_String(&self.line2, &mut ret)?;
        write_String(&self.line3, &mut ret)?;
        write_String(&self.line4, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), line1: String, line2: String, line3: String, line4: String) -> ServerboundPacket {
        ServerboundPacket::UpdateSign(UpdateSign {
            location: location,
            line1: line1,
            line2: line2,
            line3: line3,
            line4: line4,
        })
    }
    /// Get the block coordinates
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get line 1
    pub fn get_line1(&self) -> &String {
        &self.line1
    }    /// Get line 2
    pub fn get_line2(&self) -> &String {
        &self.line2
    }    /// Get line 3
    pub fn get_line3(&self) -> &String {
        &self.line3
    }    /// Get line 4
    pub fn get_line4(&self) -> &String {
        &self.line4
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Animation {
    hand: i32,
}

impl Animation {
    const PACKET_ID: i32 = 42;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Animation(Animation {
            hand: read_varint(r).chain_err(|| "while reading field hand")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(hand: i32) -> ServerboundPacket {
        ServerboundPacket::Animation(Animation {
            hand: hand,
        })
    }
    /// Get which arm was used as a raw varint enum
    pub fn get_hand(&self) -> &i32 {
        &self.hand
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Spectate {
    target: u128,
}

impl Spectate {
    const PACKET_ID: i32 = 43;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Spectate(Spectate {
            target: read_u128(r).chain_err(|| "while reading field target")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u128(&self.target, &mut ret)?;

        Ok(ret)
    }
    pub fn new(target: u128) -> ServerboundPacket {
        ServerboundPacket::Spectate(Spectate {
            target: target,
        })
    }
    /// Get the uuid of the selected target
    pub fn get_target(&self) -> &u128 {
        &self.target
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerBlockPlacement {
    hand: i32,
    location: (i32, i32, i32),
    face: i32,
    x: f32,
    y: f32,
    z: f32,
    inside_block: bool,
}

impl PlayerBlockPlacement {
    const PACKET_ID: i32 = 44;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerBlockPlacement(PlayerBlockPlacement {
            hand: read_varint(r).chain_err(|| "while reading field hand")?,
            location: read_position(r).chain_err(|| "while reading field location")?,
            face: read_varint(r).chain_err(|| "while reading field face")?,
            x: read_f32(r).chain_err(|| "while reading field x")?,
            y: read_f32(r).chain_err(|| "while reading field y")?,
            z: read_f32(r).chain_err(|| "while reading field z")?,
            inside_block: read_bool(r).chain_err(|| "while reading field inside_block")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.hand, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_varint(&self.face, &mut ret)?;
        write_f32(&self.x, &mut ret)?;
        write_f32(&self.y, &mut ret)?;
        write_f32(&self.z, &mut ret)?;
        write_bool(&self.inside_block, &mut ret)?;

        Ok(ret)
    }
    pub fn new(hand: i32, location: (i32, i32, i32), face: i32, x: f32, y: f32, z: f32, inside_block: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerBlockPlacement(PlayerBlockPlacement {
            hand: hand,
            location: location,
            face: face,
            x: x,
            y: y,
            z: z,
            inside_block: inside_block,
        })
    }
    /// Get the hand from which the block was placed as a raw varint enum
    pub fn get_hand(&self) -> &i32 {
        &self.hand
    }    /// Get the location of the placed block
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the face of the block as a raw varint enum
    pub fn get_face(&self) -> &i32 {
        &self.face
    }    /// Get the X position of the crosshair on the block
    pub fn get_x(&self) -> &f32 {
        &self.x
    }    /// Get the Y position of the crosshair on the block
    pub fn get_y(&self) -> &f32 {
        &self.y
    }    /// Get the Z position of the crosshair on the block
    pub fn get_z(&self) -> &f32 {
        &self.z
    }    /// True when the player's head is inside of a block
    pub fn get_inside_block(&self) -> &bool {
        &self.inside_block
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UseItem {
    hand: i32,
}

impl UseItem {
    const PACKET_ID: i32 = 45;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UseItem(UseItem {
            hand: read_varint(r).chain_err(|| "while reading field hand")?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(hand: i32) -> ServerboundPacket {
        ServerboundPacket::UseItem(UseItem {
            hand: hand,
        })
    }
    /// Get which hand contained the used item as a raw varint enum
    pub fn get_hand(&self) -> &i32 {
        &self.hand
    }
}

