/* This file is automatically generated by packets.clj
Do not manually edit this file, if you wish to make
changes here, then edit and rerun packets.clj */

#[derive(Debug, PartialEq, Clone)]
pub struct Handshake {
    protocol_version: i32,
    server_address: String,
    server_port: u16,
    next_state: i32,
}

impl Handshake {
    const PACKET_ID: i32 = 0;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Handshake(Handshake {
            protocol_version: read_varint(r)?,
            server_address: read_String(r)?,
            server_port: read_u16(r)?,
            next_state: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.protocol_version, &mut ret)?;
        write_String(&self.server_address, &mut ret)?;
        write_u16(&self.server_port, &mut ret)?;
        write_varint(&self.next_state, &mut ret)?;

        Ok(ret)
    }
    pub fn new(protocol_version: i32, server_address: String, server_port: u16, next_state: i32) -> ServerboundPacket {
        ServerboundPacket::Handshake(Handshake {
            protocol_version: protocol_version,
            server_address: server_address,
            server_port: server_port,
            next_state: next_state,
        })
    }
    /// Get the client's protocol version
    pub fn get_protocol_version(&self) -> &i32 {
        &self.protocol_version
    }    /// Get the hostname of the server the client connected to
    pub fn get_server_address(&self) -> &String {
        &self.server_address
    }    /// Get the port of the server the client connected to
    pub fn get_server_port(&self) -> &u16 {
        &self.server_port
    }    /// Get the next state
    pub fn get_next_state(&self) -> &i32 {
        &self.next_state
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusRequest {
}

impl StatusRequest {
    const PACKET_ID: i32 = 0;


    pub fn new_raw() -> ServerboundPacket {
        ServerboundPacket::StatusRequest(StatusRequest {
        })
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusPing {
    id: u64,
}

impl StatusPing {
    const PACKET_ID: i32 = 1;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::StatusPing(StatusPing {
            id: read_u64(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: u64) -> ServerboundPacket {
        ServerboundPacket::StatusPing(StatusPing {
            id: id,
        })
    }
    /// Get the id
    pub fn get_id(&self) -> &u64 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginStart {
    name: String,
}

impl LoginStart {
    const PACKET_ID: i32 = 0;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::LoginStart(LoginStart {
            name: read_String(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.name, &mut ret)?;

        Ok(ret)
    }
    pub fn new(name: String) -> ServerboundPacket {
        ServerboundPacket::LoginStart(LoginStart {
            name: name,
        })
    }
    /// Get the player's claimed username
    pub fn get_name(&self) -> &String {
        &self.name
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EncryptionResponse {
    shared_secret: Vec<u8>,
    verify_token: Vec<u8>,
}

impl EncryptionResponse {
    const PACKET_ID: i32 = 1;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::EncryptionResponse(EncryptionResponse {
            shared_secret: read_prefixed_bytearray(r)?,
            verify_token: read_prefixed_bytearray(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_prefixed_bytearray(&self.shared_secret, &mut ret)?;
        write_prefixed_bytearray(&self.verify_token, &mut ret)?;

        Ok(ret)
    }
    pub fn new(shared_secret: Vec<u8>, verify_token: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::EncryptionResponse(EncryptionResponse {
            shared_secret: shared_secret,
            verify_token: verify_token,
        })
    }
    /// Get the (raw encrypted) shared secret
    pub fn get_shared_secret(&self) -> &Vec<u8> {
        &self.shared_secret
    }    /// Get the (raw encrypted) verify token
    pub fn get_verify_token(&self) -> &Vec<u8> {
        &self.verify_token
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct TeleportConfirm {
    id: i32,
}

impl TeleportConfirm {
    const PACKET_ID: i32 = 0;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::TeleportConfirm(TeleportConfirm {
            id: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i32) -> ServerboundPacket {
        ServerboundPacket::TeleportConfirm(TeleportConfirm {
            id: id,
        })
    }
    /// Get the teleport id
    pub fn get_id(&self) -> &i32 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct TabComplete {
    text: String,
    assume_command: bool,
    looked_at_block: Option<(i32, i32, i32)>,
}

impl TabComplete {
    const PACKET_ID: i32 = 1;


    pub fn new_raw(text: String, assume_command: bool, looked_at_block: Option<(i32, i32, i32)>) -> ServerboundPacket {
        ServerboundPacket::TabComplete(TabComplete {
            text: text,
            assume_command: assume_command,
            looked_at_block: looked_at_block,
        })
    }
    /// Get the text
    pub fn get_text(&self) -> &String {
        &self.text
    }    /// Get whether the server should parse the text even if it doesn't start with a /
    pub fn get_assume_command(&self) -> &bool {
        &self.assume_command
    }    /// Get the position of the block being looked at (if any)
    pub fn get_looked_at_block(&self) -> &Option<(i32, i32, i32)> {
        &self.looked_at_block
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChatMessage {
    message: String,
}

impl ChatMessage {
    const PACKET_ID: i32 = 2;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ChatMessage(ChatMessage {
            message: read_String(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.message, &mut ret)?;

        Ok(ret)
    }
    pub fn new(message: String) -> ServerboundPacket {
        ServerboundPacket::ChatMessage(ChatMessage {
            message: message,
        })
    }
    /// Get the chat message (not json)
    pub fn get_message(&self) -> &String {
        &self.message
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientStatus {
    action: i32,
}

impl ClientStatus {
    const PACKET_ID: i32 = 3;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClientStatus(ClientStatus {
            action: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.action, &mut ret)?;

        Ok(ret)
    }
    pub fn new(action: i32) -> ServerboundPacket {
        ServerboundPacket::ClientStatus(ClientStatus {
            action: action,
        })
    }
    /// Get the action ID varint enum
    pub fn get_action(&self) -> &i32 {
        &self.action
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientSettings {
    locale: String,
    view_distance: u8,
    chat_mode: i32,
    chat_colors: bool,
    displayed_skin_parts: u8,
    main_hand: i32,
}

impl ClientSettings {
    const PACKET_ID: i32 = 4;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClientSettings(ClientSettings {
            locale: read_String(r)?,
            view_distance: read_u8(r)?,
            chat_mode: read_varint(r)?,
            chat_colors: read_bool(r)?,
            displayed_skin_parts: read_u8(r)?,
            main_hand: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.locale, &mut ret)?;
        write_u8(&self.view_distance, &mut ret)?;
        write_varint(&self.chat_mode, &mut ret)?;
        write_bool(&self.chat_colors, &mut ret)?;
        write_u8(&self.displayed_skin_parts, &mut ret)?;
        write_varint(&self.main_hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(locale: String, view_distance: u8, chat_mode: i32, chat_colors: bool, displayed_skin_parts: u8, main_hand: i32) -> ServerboundPacket {
        ServerboundPacket::ClientSettings(ClientSettings {
            locale: locale,
            view_distance: view_distance,
            chat_mode: chat_mode,
            chat_colors: chat_colors,
            displayed_skin_parts: displayed_skin_parts,
            main_hand: main_hand,
        })
    }
    /// Get the client's locale
    pub fn get_locale(&self) -> &String {
        &self.locale
    }    /// Get the client's view distance in chunks
    pub fn get_view_distance(&self) -> &u8 {
        &self.view_distance
    }    /// Get the client's chat mode as varint enum
    pub fn get_chat_mode(&self) -> &i32 {
        &self.chat_mode
    }    /// Get whether the player has chat colors enabled
    pub fn get_chat_colors(&self) -> &bool {
        &self.chat_colors
    }    /// Get the displayed skin parts as a raw bit mask
    pub fn get_displayed_skin_parts(&self) -> &u8 {
        &self.displayed_skin_parts
    }    /// Get the player's main hand as a varint enum
    pub fn get_main_hand(&self) -> &i32 {
        &self.main_hand
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ConfirmTransaction {
    window_id: u8,
    id: i16,
    accepted: bool,
}

impl ConfirmTransaction {
    const PACKET_ID: i32 = 5;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ConfirmTransaction(ConfirmTransaction {
            window_id: read_u8(r)?,
            id: read_i16(r)?,
            accepted: read_bool(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.id, &mut ret)?;
        write_bool(&self.accepted, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, id: i16, accepted: bool) -> ServerboundPacket {
        ServerboundPacket::ConfirmTransaction(ConfirmTransaction {
            window_id: window_id,
            id: id,
            accepted: accepted,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the action number
    pub fn get_id(&self) -> &i16 {
        &self.id
    }    /// Get whether the action was accepted
    pub fn get_accepted(&self) -> &bool {
        &self.accepted
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EnchantItem {
    window_id: u8,
    enchantment: i8,
}

impl EnchantItem {
    const PACKET_ID: i32 = 6;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::EnchantItem(EnchantItem {
            window_id: read_u8(r)?,
            enchantment: read_i8(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i8(&self.enchantment, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, enchantment: i8) -> ServerboundPacket {
        ServerboundPacket::EnchantItem(EnchantItem {
            window_id: window_id,
            enchantment: enchantment,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the position of the chosen enchantment
    pub fn get_enchantment(&self) -> &i8 {
        &self.enchantment
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClickWindow {
    window_id: u8,
    slot_id: i16,
    button: i8,
    id: i16,
    mode: i32,
    slot: Vec<u8>,
}

impl ClickWindow {
    const PACKET_ID: i32 = 7;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ClickWindow(ClickWindow {
            window_id: read_u8(r)?,
            slot_id: read_i16(r)?,
            button: read_i8(r)?,
            id: read_i16(r)?,
            mode: read_varint(r)?,
            slot: read_bytearray(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_i8(&self.button, &mut ret)?;
        write_i16(&self.id, &mut ret)?;
        write_varint(&self.mode, &mut ret)?;
        write_bytearray(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, slot_id: i16, button: i8, id: i16, mode: i32, slot: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::ClickWindow(ClickWindow {
            window_id: window_id,
            slot_id: slot_id,
            button: button,
            id: id,
            mode: mode,
            slot: slot,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the clicked slot number
    pub fn get_slot_id(&self) -> &i16 {
        &self.slot_id
    }    /// Get the button clicked byte enum
    pub fn get_button(&self) -> &i8 {
        &self.button
    }    /// Get the action number id
    pub fn get_id(&self) -> &i16 {
        &self.id
    }    /// Get the action/mode
    pub fn get_mode(&self) -> &i32 {
        &self.mode
    }    /// Get the raw unprocessed slot data
    pub fn get_slot(&self) -> &Vec<u8> {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CloseWindow {
    window_id: u8,
}

impl CloseWindow {
    const PACKET_ID: i32 = 8;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::CloseWindow(CloseWindow {
            window_id: read_u8(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8) -> ServerboundPacket {
        ServerboundPacket::CloseWindow(CloseWindow {
            window_id: window_id,
        })
    }
    /// Get the window id
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PluginMessage {
    channel: String,
    data: Vec<u8>,
}

impl PluginMessage {
    const PACKET_ID: i32 = 9;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PluginMessage(PluginMessage {
            channel: read_String(r)?,
            data: read_bytearray(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_String(&self.channel, &mut ret)?;
        write_bytearray(&self.data, &mut ret)?;

        Ok(ret)
    }
    pub fn new(channel: String, data: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::PluginMessage(PluginMessage {
            channel: channel,
            data: data,
        })
    }
    /// Get the channel
    pub fn get_channel(&self) -> &String {
        &self.channel
    }    /// Get the data
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UseEntity {
    target: i32,
    action: i32,
    location: Option<(f32, f32, f32)>,
    hand: Option<i32>,
}

impl UseEntity {
    const PACKET_ID: i32 = 10;


    pub fn new_raw(target: i32, action: i32, location: Option<(f32, f32, f32)>, hand: Option<i32>) -> ServerboundPacket {
        ServerboundPacket::UseEntity(UseEntity {
            target: target,
            action: action,
            location: location,
            hand: hand,
        })
    }
    /// Get the target eid
    pub fn get_target(&self) -> &i32 {
        &self.target
    }    /// Get the action type varint enum
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get the target location (if any)
    pub fn get_location(&self) -> &Option<(f32, f32, f32)> {
        &self.location
    }    /// Get the hand used as a varint enum (if any)
    pub fn get_hand(&self) -> &Option<i32> {
        &self.hand
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct KeepAlive {
    id: i64,
}

impl KeepAlive {
    const PACKET_ID: i32 = 11;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::KeepAlive(KeepAlive {
            id: read_i64(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i64(&self.id, &mut ret)?;

        Ok(ret)
    }
    pub fn new(id: i64) -> ServerboundPacket {
        ServerboundPacket::KeepAlive(KeepAlive {
            id: id,
        })
    }
    /// Get the keep alive ID
    pub fn get_id(&self) -> &i64 {
        &self.id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Player {
    on_ground: bool,
}

impl Player {
    const PACKET_ID: i32 = 12;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Player(Player {
            on_ground: read_bool(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::Player(Player {
            on_ground: on_ground,
        })
    }
    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPosition {
    x: f64,
    y: f64,
    z: f64,
    on_ground: bool,
}

impl PlayerPosition {
    const PACKET_ID: i32 = 13;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerPosition(PlayerPosition {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerPosition(PlayerPosition {
            x: x,
            y: y,
            z: z,
            on_ground: on_ground,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate (feet)
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPositionAndLook {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
    on_ground: bool,
}

impl PlayerPositionAndLook {
    const PACKET_ID: i32 = 14;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerLook {
    yaw: f32,
    pitch: f32,
    on_ground: bool,
}

impl PlayerLook {
    const PACKET_ID: i32 = 15;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerLook(PlayerLook {
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,
            on_ground: read_bool(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;
        write_bool(&self.on_ground, &mut ret)?;

        Ok(ret)
    }
    pub fn new(yaw: f32, pitch: f32, on_ground: bool) -> ServerboundPacket {
        ServerboundPacket::PlayerLook(PlayerLook {
            yaw: yaw,
            pitch: pitch,
            on_ground: on_ground,
        })
    }
    /// Get the yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct VehicleMove {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
}

impl VehicleMove {
    const PACKET_ID: i32 = 16;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::VehicleMove(VehicleMove {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f64(&self.x, &mut ret)?;
        write_f64(&self.y, &mut ret)?;
        write_f64(&self.z, &mut ret)?;
        write_f32(&self.yaw, &mut ret)?;
        write_f32(&self.pitch, &mut ret)?;

        Ok(ret)
    }
    pub fn new(x: f64, y: f64, z: f64, yaw: f32, pitch: f32) -> ServerboundPacket {
        ServerboundPacket::VehicleMove(VehicleMove {
            x: x,
            y: y,
            z: z,
            yaw: yaw,
            pitch: pitch,
        })
    }
    /// Get the (absolute) X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }    /// Get the (absolute) Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }    /// Get the (absolute) Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }    /// Get the (absolute) yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SteerBoat {
    right: bool,
    left: bool,
}

impl SteerBoat {
    const PACKET_ID: i32 = 17;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::SteerBoat(SteerBoat {
            right: read_bool(r)?,
            left: read_bool(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_bool(&self.right, &mut ret)?;
        write_bool(&self.left, &mut ret)?;

        Ok(ret)
    }
    pub fn new(right: bool, left: bool) -> ServerboundPacket {
        ServerboundPacket::SteerBoat(SteerBoat {
            right: right,
            left: left,
        })
    }
    /// Get whether the right paddle is turning
    pub fn get_right(&self) -> &bool {
        &self.right
    }    /// Get whether the left paddle is turning
    pub fn get_left(&self) -> &bool {
        &self.left
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CraftRecipeRequest {
    window_id: u8,
    recipe: i32,
    make_all: bool,
}

impl CraftRecipeRequest {
    const PACKET_ID: i32 = 18;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::CraftRecipeRequest(CraftRecipeRequest {
            window_id: read_u8(r)?,
            recipe: read_varint(r)?,
            make_all: read_bool(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.window_id, &mut ret)?;
        write_varint(&self.recipe, &mut ret)?;
        write_bool(&self.make_all, &mut ret)?;

        Ok(ret)
    }
    pub fn new(window_id: u8, recipe: i32, make_all: bool) -> ServerboundPacket {
        ServerboundPacket::CraftRecipeRequest(CraftRecipeRequest {
            window_id: window_id,
            recipe: recipe,
            make_all: make_all,
        })
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }    /// Get the recipe ID
    pub fn get_recipe(&self) -> &i32 {
        &self.recipe
    }    /// Get if shift was down when the item was clicked
    pub fn get_make_all(&self) -> &bool {
        &self.make_all
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerAbilities {
    flags: u8,
    flying_speed: f32,
    walking_speed: f32,
}

impl PlayerAbilities {
    const PACKET_ID: i32 = 19;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerAbilities(PlayerAbilities {
            flags: read_u8(r)?,
            flying_speed: read_f32(r)?,
            walking_speed: read_f32(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;
        write_f32(&self.flying_speed, &mut ret)?;
        write_f32(&self.walking_speed, &mut ret)?;

        Ok(ret)
    }
    pub fn new(flags: u8, flying_speed: f32, walking_speed: f32) -> ServerboundPacket {
        ServerboundPacket::PlayerAbilities(PlayerAbilities {
            flags: flags,
            flying_speed: flying_speed,
            walking_speed: walking_speed,
        })
    }
    /// Get the raw player abilities bit mask
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }    /// Get the player's flying speed
    pub fn get_flying_speed(&self) -> &f32 {
        &self.flying_speed
    }    /// Get the player's walking speed
    pub fn get_walking_speed(&self) -> &f32 {
        &self.walking_speed
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerDigging {
    status: i32,
    location: (i32, i32, i32),
    face: u8,
}

impl PlayerDigging {
    const PACKET_ID: i32 = 20;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerDigging(PlayerDigging {
            status: read_varint(r)?,
            location: read_position(r)?,
            face: read_u8(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.status, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_u8(&self.face, &mut ret)?;

        Ok(ret)
    }
    pub fn new(status: i32, location: (i32, i32, i32), face: u8) -> ServerboundPacket {
        ServerboundPacket::PlayerDigging(PlayerDigging {
            status: status,
            location: location,
            face: face,
        })
    }
    /// Get the status as a raw varint enum
    pub fn get_status(&self) -> &i32 {
        &self.status
    }    /// Get the location of the block
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the face of the block being hit as a raw byte enum
    pub fn get_face(&self) -> &u8 {
        &self.face
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityAction {
    entity_id: i32,
    action: i32,
    jump_boost: i32,
}

impl EntityAction {
    const PACKET_ID: i32 = 21;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::EntityAction(EntityAction {
            entity_id: read_varint(r)?,
            action: read_varint(r)?,
            jump_boost: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.entity_id, &mut ret)?;
        write_varint(&self.action, &mut ret)?;
        write_varint(&self.jump_boost, &mut ret)?;

        Ok(ret)
    }
    pub fn new(entity_id: i32, action: i32, jump_boost: i32) -> ServerboundPacket {
        ServerboundPacket::EntityAction(EntityAction {
            entity_id: entity_id,
            action: action,
            jump_boost: jump_boost,
        })
    }
    /// Get the player's eid
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }    /// Get the action as a raw varint enum
    pub fn get_action(&self) -> &i32 {
        &self.action
    }    /// Get the jump boost, used if the player is riding a horse
    pub fn get_jump_boost(&self) -> &i32 {
        &self.jump_boost
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct SteerVehicle {
    sideways: f32,
    forward: f32,
    flags: u8,
}

impl SteerVehicle {
    const PACKET_ID: i32 = 22;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::SteerVehicle(SteerVehicle {
            sideways: read_f32(r)?,
            forward: read_f32(r)?,
            flags: read_u8(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_f32(&self.sideways, &mut ret)?;
        write_f32(&self.forward, &mut ret)?;
        write_u8(&self.flags, &mut ret)?;

        Ok(ret)
    }
    pub fn new(sideways: f32, forward: f32, flags: u8) -> ServerboundPacket {
        ServerboundPacket::SteerVehicle(SteerVehicle {
            sideways: sideways,
            forward: forward,
            flags: flags,
        })
    }
    /// Get the sideways movement, positiev is to the left of the player
    pub fn get_sideways(&self) -> &f32 {
        &self.sideways
    }    /// Get the forward movement
    pub fn get_forward(&self) -> &f32 {
        &self.forward
    }    /// Get the raw flags byte enum
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CraftingBookData {
    displayed_recipe: Option<i32>,
    crafting_book_status: Option<(bool, bool)>,
}

impl CraftingBookData {
    const PACKET_ID: i32 = 23;


    pub fn new_raw(displayed_recipe: Option<i32>, crafting_book_status: Option<(bool, bool)>) -> ServerboundPacket {
        ServerboundPacket::CraftingBookData(CraftingBookData {
            displayed_recipe: displayed_recipe,
            crafting_book_status: crafting_book_status,
        })
    }
    /// Get the displayed recipe, if the type of this packet is displayed recipe
    pub fn get_displayed_recipe(&self) -> &Option<i32> {
        &self.displayed_recipe
    }    /// Get the values (Crafting book open, Crafting filter), if the tyep of this packet is crafting book status
    pub fn get_crafting_book_status(&self) -> &Option<(bool, bool)> {
        &self.crafting_book_status
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct ResourcePackStatus {
    result: i32,
}

impl ResourcePackStatus {
    const PACKET_ID: i32 = 24;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::ResourcePackStatus(ResourcePackStatus {
            result: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.result, &mut ret)?;

        Ok(ret)
    }
    pub fn new(result: i32) -> ServerboundPacket {
        ServerboundPacket::ResourcePackStatus(ResourcePackStatus {
            result: result,
        })
    }
    /// Get the result as a raw varint enum
    pub fn get_result(&self) -> &i32 {
        &self.result
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct AdvancementTab {
    tab_id: Option<String>,
}

impl AdvancementTab {
    const PACKET_ID: i32 = 25;


    pub fn new_raw(tab_id: Option<String>) -> ServerboundPacket {
        ServerboundPacket::AdvancementTab(AdvancementTab {
            tab_id: tab_id,
        })
    }
    /// Get Some(Tab ID) if the action was to open a tab, and None else
    pub fn get_tab_id(&self) -> &Option<String> {
        &self.tab_id
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct HeldItemChange {
    slot: i16,
}

impl HeldItemChange {
    const PACKET_ID: i32 = 26;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::HeldItemChange(HeldItemChange {
            slot: read_i16(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i16(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot: i16) -> ServerboundPacket {
        ServerboundPacket::HeldItemChange(HeldItemChange {
            slot: slot,
        })
    }
    /// Get the slot the player has selected
    pub fn get_slot(&self) -> &i16 {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct CreativeInventoryAction {
    slot_id: i16,
    slot: Vec<u8>,
}

impl CreativeInventoryAction {
    const PACKET_ID: i32 = 27;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::CreativeInventoryAction(CreativeInventoryAction {
            slot_id: read_i16(r)?,
            slot: read_bytearray(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_i16(&self.slot_id, &mut ret)?;
        write_bytearray(&self.slot, &mut ret)?;

        Ok(ret)
    }
    pub fn new(slot_id: i16, slot: Vec<u8>) -> ServerboundPacket {
        ServerboundPacket::CreativeInventoryAction(CreativeInventoryAction {
            slot_id: slot_id,
            slot: slot,
        })
    }
    /// Get the inventory slot number
    pub fn get_slot_id(&self) -> &i16 {
        &self.slot_id
    }    /// Get the raw unprocessed slot data
    pub fn get_slot(&self) -> &Vec<u8> {
        &self.slot
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateSign {
    location: (i32, i32, i32),
    line1: String,
    line2: String,
    line3: String,
    line4: String,
}

impl UpdateSign {
    const PACKET_ID: i32 = 28;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UpdateSign(UpdateSign {
            location: read_position(r)?,
            line1: read_String(r)?,
            line2: read_String(r)?,
            line3: read_String(r)?,
            line4: read_String(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_String(&self.line1, &mut ret)?;
        write_String(&self.line2, &mut ret)?;
        write_String(&self.line3, &mut ret)?;
        write_String(&self.line4, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), line1: String, line2: String, line3: String, line4: String) -> ServerboundPacket {
        ServerboundPacket::UpdateSign(UpdateSign {
            location: location,
            line1: line1,
            line2: line2,
            line3: line3,
            line4: line4,
        })
    }
    /// Get the block coordinates
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get line 1
    pub fn get_line1(&self) -> &String {
        &self.line1
    }    /// Get line 2
    pub fn get_line2(&self) -> &String {
        &self.line2
    }    /// Get line 3
    pub fn get_line3(&self) -> &String {
        &self.line3
    }    /// Get line 4
    pub fn get_line4(&self) -> &String {
        &self.line4
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Animation {
    hand: i32,
}

impl Animation {
    const PACKET_ID: i32 = 29;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Animation(Animation {
            hand: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(hand: i32) -> ServerboundPacket {
        ServerboundPacket::Animation(Animation {
            hand: hand,
        })
    }
    /// Get which arm was used as a raw varint enum
    pub fn get_hand(&self) -> &i32 {
        &self.hand
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct Spectate {
    target: u128,
}

impl Spectate {
    const PACKET_ID: i32 = 30;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::Spectate(Spectate {
            target: read_u128(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_u128(&self.target, &mut ret)?;

        Ok(ret)
    }
    pub fn new(target: u128) -> ServerboundPacket {
        ServerboundPacket::Spectate(Spectate {
            target: target,
        })
    }
    /// Get the uuid of the selected target
    pub fn get_target(&self) -> &u128 {
        &self.target
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerBlockPlacement {
    location: (i32, i32, i32),
    face: i32,
    hand: i32,
    x: f32,
    y: f32,
    z: f32,
}

impl PlayerBlockPlacement {
    const PACKET_ID: i32 = 31;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::PlayerBlockPlacement(PlayerBlockPlacement {
            location: read_position(r)?,
            face: read_varint(r)?,
            hand: read_varint(r)?,
            x: read_f32(r)?,
            y: read_f32(r)?,
            z: read_f32(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_position(&self.location, &mut ret)?;
        write_varint(&self.face, &mut ret)?;
        write_varint(&self.hand, &mut ret)?;
        write_f32(&self.x, &mut ret)?;
        write_f32(&self.y, &mut ret)?;
        write_f32(&self.z, &mut ret)?;

        Ok(ret)
    }
    pub fn new(location: (i32, i32, i32), face: i32, hand: i32, x: f32, y: f32, z: f32) -> ServerboundPacket {
        ServerboundPacket::PlayerBlockPlacement(PlayerBlockPlacement {
            location: location,
            face: face,
            hand: hand,
            x: x,
            y: y,
            z: z,
        })
    }
    /// Get the location of the placed block
    pub fn get_location(&self) -> &(i32, i32, i32) {
        &self.location
    }    /// Get the face of the block as a raw varint enum
    pub fn get_face(&self) -> &i32 {
        &self.face
    }    /// Get the hand from which the block was placed as a raw varint enum
    pub fn get_hand(&self) -> &i32 {
        &self.hand
    }    /// Get the X position of the crosshair on the block
    pub fn get_x(&self) -> &f32 {
        &self.x
    }    /// Get the Y position of the crosshair on the block
    pub fn get_y(&self) -> &f32 {
        &self.y
    }    /// Get the Z position of the crosshair on the block
    pub fn get_z(&self) -> &f32 {
        &self.z
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct UseItem {
    hand: i32,
}

impl UseItem {
    const PACKET_ID: i32 = 32;
    /// Deserializes a Read type into a packet. You usually won't need to use this.
    pub fn deserialize<R: Read>(r: &mut R) -> Result<ServerboundPacket> {
        Ok(ServerboundPacket::UseItem(UseItem {
            hand: read_varint(r)?,

        }))
    }
    /// Serializes the packet into Vec<u8>. You usually won't need to use this.
    pub fn to_u8(&self) -> Result<Vec<u8>> {
        let mut ret = Vec::new();
        write_varint(&Self::PACKET_ID, &mut ret)?;
        write_varint(&self.hand, &mut ret)?;

        Ok(ret)
    }
    pub fn new(hand: i32) -> ServerboundPacket {
        ServerboundPacket::UseItem(UseItem {
            hand: hand,
        })
    }
    /// Get which hand contained the used item as a raw varint enum
    pub fn get_hand(&self) -> &i32 {
        &self.hand
    }
}

