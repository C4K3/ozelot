/* This file is automatically generated by packets.clj
Do not manually edit this file, if you wish to make
changes here, then edit and rerun packets.clj */

#[derive(Debug, PartialEq, Clone)]
pub enum ClientboundPacket {
    StatusResponse(StatusResponse),
    StatusPong(StatusPong),
    LoginDisconnect(LoginDisconnect),
    EncryptionRequest(EncryptionRequest),
    LoginSuccess(LoginSuccess),
    SetCompression(SetCompression),
    SpawnObject(SpawnObject),
    SpawnExperienceOrb(SpawnExperienceOrb),
    SpawnGlobalEntity(SpawnGlobalEntity),
    SpawnMob(SpawnMob),
    SpawnPainting(SpawnPainting),
    SpawnPlayer(SpawnPlayer),
    ClientboundAnimation(ClientboundAnimation),
    Statistics(Statistics),
    BlockBreakAnimation(BlockBreakAnimation),
    UpdateBlockEntity(UpdateBlockEntity),
    BlockAction(BlockAction),
    BlockChange(BlockChange),
    ServerDifficulty(ServerDifficulty),
    ClientboundTabComplete(ClientboundTabComplete),
    ChatMessage(ChatMessage),
    MultiBlockChange(MultiBlockChange),
    ClientboundConfirmTransaction(ClientboundConfirmTransaction),
    ClientboundCloseWindow(ClientboundCloseWindow),
    OpenWindow(OpenWindow),
    WindowItems(WindowItems),
    WindowProperty(WindowProperty),
    SetSlot(SetSlot),
    SetCooldown(SetCooldown),
    ClientboundPluginMessage(ClientboundPluginMessage),
    NamedSoundEffect(NamedSoundEffect),
    PlayDisconnect(PlayDisconnect),
    EntityStatus(EntityStatus),
    Explosion(Explosion),
    UnloadChunk(UnloadChunk),
    ChangeGameState(ChangeGameState),
    KeepAlive(KeepAlive),
    ChunkData(ChunkData),
    Effect(Effect),
    Particle(Particle),
    JoinGame(JoinGame),
    Map(Map),
    EntityRelativeMove(EntityRelativeMove),
    EntityLookRelativeMove(EntityLookRelativeMove),
    EntityLook(EntityLook),
    Entity(Entity),
    ClientboundVehicleMove(ClientboundVehicleMove),
    OpenSignEditor(OpenSignEditor),
    PlayerAbilities(PlayerAbilities),
    CombatEvent(CombatEvent),
    PlayerListItem(PlayerListItem),
    PlayerPositionAndLook(PlayerPositionAndLook),
    UseBed(UseBed),
    DestroyEntities(DestroyEntities),
    RemoveEntityEffect(RemoveEntityEffect),
    ResourcePackSend(ResourcePackSend),
    Respawn(Respawn),
    EntityHeadLook(EntityHeadLook),
    WorldBorder(WorldBorder),
    Camera(Camera),
    ClientboundHeldItemChange(ClientboundHeldItemChange),
    DisplayScoreboard(DisplayScoreboard),
    EntityMetadata(EntityMetadata),
    AttachEntity(AttachEntity),
    EntityVelocity(EntityVelocity),
    EntityEquipment(EntityEquipment),
    SetExperience(SetExperience),
    UpdateHealth(UpdateHealth),
    ScoreboardObjective(ScoreboardObjective),
    SetPassengers(SetPassengers),
    Teams(Teams),
    UpdateScore(UpdateScore),
    SpawnPosition(SpawnPosition),
    TimeUpdate(TimeUpdate),
    Title(Title),
    SoundEffect(SoundEffect),
    PlayerListHeaderFooter(PlayerListHeaderFooter),
    CollectItem(CollectItem),
    EntityTeleport(EntityTeleport),
    EntityProperties(EntityProperties),
    EntityEffect(EntityEffect),
}

impl ClientboundPacket {
    /// Given a reader over precisely one packet, parse it into a packet.
    /// Assumes that encryption/compression has already been stripped,
    /// and the first byte from the reader is the one that specifies the
    /// the packet id.
    pub fn parse<R: Read>(r: &mut R, state: &ClientState) -> io::Result<Self> {
        let packet_id = read_varint(r)?;
        //println!("packet_id = {}, state = {:?}", packet_id, state);
        Ok(match state {
            &ClientState::Handshake => {
                return io_error!("No packet available in this state");
            },
            &ClientState::Status => {
            match packet_id {
                0 => StatusResponse::new(r)?,
                1 => StatusPong::new(r)?,
                _ => return io_error!("No packet with id {} in state {:?}", packet_id, state),            }
            },
            &ClientState::Login => {
            match packet_id {
                0 => LoginDisconnect::new(r)?,
                1 => EncryptionRequest::new(r)?,
                2 => LoginSuccess::new(r)?,
                3 => SetCompression::new(r)?,
                _ => return io_error!("No packet with id {} in state {:?}", packet_id, state),            }
            },
            &ClientState::Play => {
            match packet_id {
                0 => SpawnObject::new(r)?,
                1 => SpawnExperienceOrb::new(r)?,
                2 => SpawnGlobalEntity::new(r)?,
                3 => SpawnMob::new(r)?,
                4 => SpawnPainting::new(r)?,
                5 => SpawnPlayer::new(r)?,
                6 => ClientboundAnimation::new(r)?,
                7 => Statistics::new(r)?,
                8 => BlockBreakAnimation::new(r)?,
                9 => UpdateBlockEntity::new(r)?,
                10 => BlockAction::new(r)?,
                11 => BlockChange::new(r)?,
                13 => ServerDifficulty::new(r)?,
                14 => ClientboundTabComplete::new(r)?,
                15 => ChatMessage::new(r)?,
                16 => MultiBlockChange::new(r)?,
                17 => ClientboundConfirmTransaction::new(r)?,
                18 => ClientboundCloseWindow::new(r)?,
                19 => OpenWindow::new(r)?,
                20 => WindowItems::new(r)?,
                21 => WindowProperty::new(r)?,
                22 => SetSlot::new(r)?,
                23 => SetCooldown::new(r)?,
                24 => ClientboundPluginMessage::new(r)?,
                25 => NamedSoundEffect::new(r)?,
                26 => PlayDisconnect::new(r)?,
                27 => EntityStatus::new(r)?,
                28 => Explosion::new(r)?,
                29 => UnloadChunk::new(r)?,
                30 => ChangeGameState::new(r)?,
                31 => KeepAlive::new(r)?,
                32 => ChunkData::new(r)?,
                33 => Effect::new(r)?,
                34 => Particle::new(r)?,
                35 => JoinGame::new(r)?,
                36 => Map::new(r)?,
                37 => EntityRelativeMove::new(r)?,
                38 => EntityLookRelativeMove::new(r)?,
                39 => EntityLook::new(r)?,
                40 => Entity::new(r)?,
                41 => ClientboundVehicleMove::new(r)?,
                42 => OpenSignEditor::new(r)?,
                43 => PlayerAbilities::new(r)?,
                44 => CombatEvent::new(r)?,
                45 => PlayerListItem::new(r)?,
                46 => PlayerPositionAndLook::new(r)?,
                47 => UseBed::new(r)?,
                48 => DestroyEntities::new(r)?,
                49 => RemoveEntityEffect::new(r)?,
                50 => ResourcePackSend::new(r)?,
                51 => Respawn::new(r)?,
                52 => EntityHeadLook::new(r)?,
                53 => WorldBorder::new(r)?,
                54 => Camera::new(r)?,
                55 => ClientboundHeldItemChange::new(r)?,
                56 => DisplayScoreboard::new(r)?,
                57 => EntityMetadata::new(r)?,
                58 => AttachEntity::new(r)?,
                59 => EntityVelocity::new(r)?,
                60 => EntityEquipment::new(r)?,
                61 => SetExperience::new(r)?,
                62 => UpdateHealth::new(r)?,
                63 => ScoreboardObjective::new(r)?,
                64 => SetPassengers::new(r)?,
                65 => Teams::new(r)?,
                66 => UpdateScore::new(r)?,
                67 => SpawnPosition::new(r)?,
                68 => TimeUpdate::new(r)?,
                69 => Title::new(r)?,
                70 => SoundEffect::new(r)?,
                71 => PlayerListHeaderFooter::new(r)?,
                72 => CollectItem::new(r)?,
                73 => EntityTeleport::new(r)?,
                74 => EntityProperties::new(r)?,
                75 => EntityEffect::new(r)?,
                _ => return io_error!("No packet with id {} in state {:?}", packet_id, state),            }
            },
        })
    }
    /// Return the name of the packet type
    pub fn get_packet_name(&self) -> &str {
        match self {
            &ClientboundPacket::StatusResponse(_) => "StatusResponse",
            &ClientboundPacket::StatusPong(_) => "StatusPong",
            &ClientboundPacket::LoginDisconnect(_) => "LoginDisconnect",
            &ClientboundPacket::EncryptionRequest(_) => "EncryptionRequest",
            &ClientboundPacket::LoginSuccess(_) => "LoginSuccess",
            &ClientboundPacket::SetCompression(_) => "SetCompression",
            &ClientboundPacket::SpawnObject(_) => "SpawnObject",
            &ClientboundPacket::SpawnExperienceOrb(_) => "SpawnExperienceOrb",
            &ClientboundPacket::SpawnGlobalEntity(_) => "SpawnGlobalEntity",
            &ClientboundPacket::SpawnMob(_) => "SpawnMob",
            &ClientboundPacket::SpawnPainting(_) => "SpawnPainting",
            &ClientboundPacket::SpawnPlayer(_) => "SpawnPlayer",
            &ClientboundPacket::ClientboundAnimation(_) => "ClientboundAnimation",
            &ClientboundPacket::Statistics(_) => "Statistics",
            &ClientboundPacket::BlockBreakAnimation(_) => "BlockBreakAnimation",
            &ClientboundPacket::UpdateBlockEntity(_) => "UpdateBlockEntity",
            &ClientboundPacket::BlockAction(_) => "BlockAction",
            &ClientboundPacket::BlockChange(_) => "BlockChange",
            &ClientboundPacket::ServerDifficulty(_) => "ServerDifficulty",
            &ClientboundPacket::ClientboundTabComplete(_) => "ClientboundTabComplete",
            &ClientboundPacket::ChatMessage(_) => "ChatMessage",
            &ClientboundPacket::MultiBlockChange(_) => "MultiBlockChange",
            &ClientboundPacket::ClientboundConfirmTransaction(_) => "ClientboundConfirmTransaction",
            &ClientboundPacket::ClientboundCloseWindow(_) => "ClientboundCloseWindow",
            &ClientboundPacket::OpenWindow(_) => "OpenWindow",
            &ClientboundPacket::WindowItems(_) => "WindowItems",
            &ClientboundPacket::WindowProperty(_) => "WindowProperty",
            &ClientboundPacket::SetSlot(_) => "SetSlot",
            &ClientboundPacket::SetCooldown(_) => "SetCooldown",
            &ClientboundPacket::ClientboundPluginMessage(_) => "ClientboundPluginMessage",
            &ClientboundPacket::NamedSoundEffect(_) => "NamedSoundEffect",
            &ClientboundPacket::PlayDisconnect(_) => "PlayDisconnect",
            &ClientboundPacket::EntityStatus(_) => "EntityStatus",
            &ClientboundPacket::Explosion(_) => "Explosion",
            &ClientboundPacket::UnloadChunk(_) => "UnloadChunk",
            &ClientboundPacket::ChangeGameState(_) => "ChangeGameState",
            &ClientboundPacket::KeepAlive(_) => "KeepAlive",
            &ClientboundPacket::ChunkData(_) => "ChunkData",
            &ClientboundPacket::Effect(_) => "Effect",
            &ClientboundPacket::Particle(_) => "Particle",
            &ClientboundPacket::JoinGame(_) => "JoinGame",
            &ClientboundPacket::Map(_) => "Map",
            &ClientboundPacket::EntityRelativeMove(_) => "EntityRelativeMove",
            &ClientboundPacket::EntityLookRelativeMove(_) => "EntityLookRelativeMove",
            &ClientboundPacket::EntityLook(_) => "EntityLook",
            &ClientboundPacket::Entity(_) => "Entity",
            &ClientboundPacket::ClientboundVehicleMove(_) => "ClientboundVehicleMove",
            &ClientboundPacket::OpenSignEditor(_) => "OpenSignEditor",
            &ClientboundPacket::PlayerAbilities(_) => "PlayerAbilities",
            &ClientboundPacket::CombatEvent(_) => "CombatEvent",
            &ClientboundPacket::PlayerListItem(_) => "PlayerListItem",
            &ClientboundPacket::PlayerPositionAndLook(_) => "PlayerPositionAndLook",
            &ClientboundPacket::UseBed(_) => "UseBed",
            &ClientboundPacket::DestroyEntities(_) => "DestroyEntities",
            &ClientboundPacket::RemoveEntityEffect(_) => "RemoveEntityEffect",
            &ClientboundPacket::ResourcePackSend(_) => "ResourcePackSend",
            &ClientboundPacket::Respawn(_) => "Respawn",
            &ClientboundPacket::EntityHeadLook(_) => "EntityHeadLook",
            &ClientboundPacket::WorldBorder(_) => "WorldBorder",
            &ClientboundPacket::Camera(_) => "Camera",
            &ClientboundPacket::ClientboundHeldItemChange(_) => "ClientboundHeldItemChange",
            &ClientboundPacket::DisplayScoreboard(_) => "DisplayScoreboard",
            &ClientboundPacket::EntityMetadata(_) => "EntityMetadata",
            &ClientboundPacket::AttachEntity(_) => "AttachEntity",
            &ClientboundPacket::EntityVelocity(_) => "EntityVelocity",
            &ClientboundPacket::EntityEquipment(_) => "EntityEquipment",
            &ClientboundPacket::SetExperience(_) => "SetExperience",
            &ClientboundPacket::UpdateHealth(_) => "UpdateHealth",
            &ClientboundPacket::ScoreboardObjective(_) => "ScoreboardObjective",
            &ClientboundPacket::SetPassengers(_) => "SetPassengers",
            &ClientboundPacket::Teams(_) => "Teams",
            &ClientboundPacket::UpdateScore(_) => "UpdateScore",
            &ClientboundPacket::SpawnPosition(_) => "SpawnPosition",
            &ClientboundPacket::TimeUpdate(_) => "TimeUpdate",
            &ClientboundPacket::Title(_) => "Title",
            &ClientboundPacket::SoundEffect(_) => "SoundEffect",
            &ClientboundPacket::PlayerListHeaderFooter(_) => "PlayerListHeaderFooter",
            &ClientboundPacket::CollectItem(_) => "CollectItem",
            &ClientboundPacket::EntityTeleport(_) => "EntityTeleport",
            &ClientboundPacket::EntityProperties(_) => "EntityProperties",
            &ClientboundPacket::EntityEffect(_) => "EntityEffect",

        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusResponse {
    json: String,
}

impl StatusResponse {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::StatusResponse(StatusResponse {
            json: read_String(r)?,
        }))
    }
    /// Get the raw json response
    pub fn get_json(&self) -> &String {
        &self.json
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct StatusPong {
    id: u64,
}

impl StatusPong {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::StatusPong(StatusPong {
            id: read_u64(r)?,
        }))
    }
    /// Get the id of the ping/pong
    pub fn get_id(&self) -> &u64 {
        &self.id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginDisconnect {
    raw_chat: String,
}

impl LoginDisconnect {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::LoginDisconnect(LoginDisconnect {
            raw_chat: read_String(r)?,
        }))
    }
    /// Get the raw chat json
    pub fn get_raw_chat(&self) -> &String {
        &self.raw_chat
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EncryptionRequest {
    server_id: String,
    public_key: Vec<u8>,
    verify_token: Vec<u8>,
}

impl EncryptionRequest {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EncryptionRequest(EncryptionRequest {
            server_id: read_String(r)?,
            public_key: read_prefixed_bytearray(r)?,
            verify_token: read_prefixed_bytearray(r)?,
        }))
    }
    /// Get the server id, currently appears to be unused
    pub fn get_server_id(&self) -> &String {
        &self.server_id
    }

    /// Get the public key
    pub fn get_public_key(&self) -> &Vec<u8> {
        &self.public_key
    }

    /// Get the verify token
    pub fn get_verify_token(&self) -> &Vec<u8> {
        &self.verify_token
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct LoginSuccess {
    uuid: u128,
    username: String,
}

impl LoginSuccess {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::LoginSuccess(LoginSuccess {
            uuid: read_uuid_str(r)?,
            username: read_String(r)?,
        }))
    }
    /// Get the player's uuid
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }

    /// Get the player's name
    pub fn get_username(&self) -> &String {
        &self.username
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SetCompression {
    threshold: i32,
}

impl SetCompression {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetCompression(SetCompression {
            threshold: read_varint(r)?,
        }))
    }
    /// Get the compression threshold
    pub fn get_threshold(&self) -> &i32 {
        &self.threshold
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnObject {
    entity_id: i32,
    object_uuid: u128,
    object_type: u8,
    x: f64,
    y: f64,
    z: f64,
    pitch: i8,
    yaw: i8,
    data: i32,
    velocity_x: i16,
    velocity_y: i16,
    velocity_z: i16,
}

impl SpawnObject {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnObject(SpawnObject {
            entity_id: read_varint(r)?,
            object_uuid: read_uuid(r)?,
            object_type: read_u8(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            pitch: read_i8(r)?,
            yaw: read_i8(r)?,
            data: read_i32(r)?,
            velocity_x: read_i16(r)?,
            velocity_y: read_i16(r)?,
            velocity_z: read_i16(r)?,
        }))
    }
    /// Get the ID of the created object
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the UUID of the created object
    pub fn get_object_uuid(&self) -> &u128 {
        &self.object_uuid
    }

    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }

    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }

    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }

    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }

    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }

    /// Get the X velocity
    pub fn get_velocity_x(&self) -> &i16 {
        &self.velocity_x
    }

    /// Get the Y velocity
    pub fn get_velocity_y(&self) -> &i16 {
        &self.velocity_y
    }

    /// Get the Z velocity
    pub fn get_velocity_z(&self) -> &i16 {
        &self.velocity_z
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnExperienceOrb {
    entity_id: i32,
    x: u64,
    y: u64,
    z: u64,
    count: i16,
}

impl SpawnExperienceOrb {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnExperienceOrb(SpawnExperienceOrb {
            entity_id: read_varint(r)?,
            x: read_u64(r)?,
            y: read_u64(r)?,
            z: read_u64(r)?,
            count: read_i16(r)?,
        }))
    }
    /// Get the ID of the orb
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the X coordinate
    pub fn get_x(&self) -> &u64 {
        &self.x
    }

    /// Get the Y coordinate
    pub fn get_y(&self) -> &u64 {
        &self.y
    }

    /// Get the Z coordinate
    pub fn get_z(&self) -> &u64 {
        &self.z
    }

    /// Get the amount of experience this orb will reward
    pub fn get_count(&self) -> &i16 {
        &self.count
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnGlobalEntity {
    entity_id: i32,
    entity_type: u8,
    x: f64,
    y: f64,
    z: f64,
}

impl SpawnGlobalEntity {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnGlobalEntity(SpawnGlobalEntity {
            entity_id: read_varint(r)?,
            entity_type: read_u8(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
        }))
    }
    /// Get the ID of the entity
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }

    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }

    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnMob {
    entity_id: i32,
    uuid: u128,
    mob_type: i32,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    head_pitch: i8,
    velocity_x: i16,
    velocity_y: i16,
    velocity_z: i16,
    metadata: Vec<u8>,
}

impl SpawnMob {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnMob(SpawnMob {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            mob_type: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            head_pitch: read_i8(r)?,
            velocity_x: read_i16(r)?,
            velocity_y: read_i16(r)?,
            velocity_z: read_i16(r)?,
            metadata: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the ID of the mob
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the UUID of the mob
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }

    /// Get the type ID of the mob
    pub fn get_mob_type(&self) -> &i32 {
        &self.mob_type
    }

    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }

    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }

    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }

    /// Get the yaw of the mob
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }

    /// Get the pitch of the mob
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }

    /// Get the pitch of the head of the mob
    pub fn get_head_pitch(&self) -> &i8 {
        &self.head_pitch
    }

    /// Get the X velocity
    pub fn get_velocity_x(&self) -> &i16 {
        &self.velocity_x
    }

    /// Get the Y velocity
    pub fn get_velocity_y(&self) -> &i16 {
        &self.velocity_y
    }

    /// Get the Z velocity
    pub fn get_velocity_z(&self) -> &i16 {
        &self.velocity_z
    }

    /// Get the raw metadata field. This library does not currently attempt to parse this field
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPainting {
    entity_id: i32,
    uuid: u128,
    title: String,
    center_location: u64,
    direction: u8,
}

impl SpawnPainting {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPainting(SpawnPainting {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            title: read_String(r)?,
            center_location: read_u64(r)?,
            direction: read_u8(r)?,
        }))
    }
    /// Get the entity ID of the painting
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the UUID of the painting
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }

    /// Get the title of the painting
    pub fn get_title(&self) -> &String {
        &self.title
    }

    /// The direction in which the painting faces
    pub fn get_direction(&self) -> &u8 {
        &self.direction
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPlayer {
    entity_id: i32,
    uuid: u128,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    metadata: Vec<u8>,
}

impl SpawnPlayer {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPlayer(SpawnPlayer {
            entity_id: read_varint(r)?,
            uuid: read_uuid(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            metadata: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the entity ID of the player
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the UUID of the player
    pub fn get_uuid(&self) -> &u128 {
        &self.uuid
    }

    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }

    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }

    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }

    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }

    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }

    /// Get the raw metadata in the packet, this library does not attempt to parse this field
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundAnimation {
    entity_id: i32,
    animation: u8,
}

impl ClientboundAnimation {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundAnimation(ClientboundAnimation {
            entity_id: read_varint(r)?,
            animation: read_u8(r)?,
        }))
    }
    /// Get the entity ID doing the animation
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the byte ID for what kind of animation it is
    pub fn get_animation(&self) -> &u8 {
        &self.animation
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Statistics {
    values: BTreeMap<String, i32>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockBreakAnimation {
    entity_id: i32,
}

impl BlockBreakAnimation {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockBreakAnimation(BlockBreakAnimation {
            entity_id: read_varint(r)?,
        }))
    }
    /// Get the entity ID doing the animation
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateBlockEntity {
    position: (i32, i32, i32),
    action: u8,
    nbt: Vec<u8>,
}

impl UpdateBlockEntity {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UpdateBlockEntity(UpdateBlockEntity {
            position: read_position(r)?,
            action: read_u8(r)?,
            nbt: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }

    /// Get the action ID being performed
    pub fn get_action(&self) -> &u8 {
        &self.action
    }

    /// Get the raw NBT bytes
    pub fn get_nbt(&self) -> &Vec<u8> {
        &self.nbt
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockAction {
    position: (i32, i32, i32),
    action_id: u8,
    action_param: u8,
    block_type: i32,
}

impl BlockAction {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockAction(BlockAction {
            position: read_position(r)?,
            action_id: read_u8(r)?,
            action_param: read_u8(r)?,
            block_type: read_varint(r)?,
        }))
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }

    /// Get the action ID
    pub fn get_action_id(&self) -> &u8 {
        &self.action_id
    }

    /// Get the action parameter
    pub fn get_action_param(&self) -> &u8 {
        &self.action_param
    }

    /// Get the block type
    pub fn get_block_type(&self) -> &i32 {
        &self.block_type
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct BlockChange {
    position: (i32, i32, i32),
    new_block: i32,
}

impl BlockChange {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::BlockChange(BlockChange {
            position: read_position(r)?,
            new_block: read_varint(r)?,
        }))
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }

    /// Get the new block state ID for the block
    pub fn get_new_block(&self) -> &i32 {
        &self.new_block
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ServerDifficulty {
    difficulty: u8,
}

impl ServerDifficulty {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ServerDifficulty(ServerDifficulty {
            difficulty: read_u8(r)?,
        }))
    }
    /// Get the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundTabComplete {
    matches: Vec<String>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct ChatMessage {
    chat: String,
    position: u8,
}

impl ChatMessage {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChatMessage(ChatMessage {
            chat: read_String(r)?,
            position: read_u8(r)?,
        }))
    }
    /// Get the raw JSON data of the chat message
    pub fn get_chat(&self) -> &String {
        &self.chat
    }

    /// Get the position of the chat message
    pub fn get_position(&self) -> &u8 {
        &self.position
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct MultiBlockChange {
    chunk_x: i32,
    chunk_z: i32,
    changes: Vec<(u8, u8, u8, i32)>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundConfirmTransaction {
    window_id: u8,
    action_id: i16,
    accepted: bool,
}

impl ClientboundConfirmTransaction {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundConfirmTransaction(ClientboundConfirmTransaction {
            window_id: read_u8(r)?,
            action_id: read_i16(r)?,
            accepted: read_bool(r)?,
        }))
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }

    /// Get the action ID (nonce)
    pub fn get_action_id(&self) -> &i16 {
        &self.action_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundCloseWindow {
    window_id: u8,
}

impl ClientboundCloseWindow {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundCloseWindow(ClientboundCloseWindow {
            window_id: read_u8(r)?,
        }))
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct OpenWindow {
    window_id: u8,
    window_type: String,
    window_title: String,
    number_of_slots: u8,
    entity_id: Option<i32>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct WindowItems {
    window_id: u8,
    slots: Vec<u8>,
}

impl WindowItems {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::WindowItems(WindowItems {
            window_id: read_u8(r)?,
            slots: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }

    /// Get the remaining slot data, that is the last two fields described at http://wiki.vg/Protocol#Window_Items
    pub fn get_slots(&self) -> &Vec<u8> {
        &self.slots
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct WindowProperty {
    window_id: u8,
    property: i16,
    new_value: i16,
}

impl WindowProperty {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::WindowProperty(WindowProperty {
            window_id: read_u8(r)?,
            property: read_i16(r)?,
            new_value: read_i16(r)?,
        }))
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }

    /// Get the property being updated
    pub fn get_property(&self) -> &i16 {
        &self.property
    }

    /// Get the new value of the propery
    pub fn get_new_value(&self) -> &i16 {
        &self.new_value
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SetSlot {
    window_id: u8,
    slot_id: i16,
    slot_data: Vec<u8>,
}

impl SetSlot {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetSlot(SetSlot {
            window_id: read_u8(r)?,
            slot_id: read_i16(r)?,
            slot_data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the window ID
    pub fn get_window_id(&self) -> &u8 {
        &self.window_id
    }

    /// Get the ID of the slot to be updated
    pub fn get_slot_id(&self) -> &i16 {
        &self.slot_id
    }

    /// Get the slot data of the packet in raw, unprocessed format
    pub fn get_slot_data(&self) -> &Vec<u8> {
        &self.slot_data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SetCooldown {
    item_id: i32,
    cooldown: i32,
}

impl SetCooldown {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetCooldown(SetCooldown {
            item_id: read_varint(r)?,
            cooldown: read_varint(r)?,
        }))
    }
    /// Get the ID of the item the cool applied to
    pub fn get_item_id(&self) -> &i32 {
        &self.item_id
    }

    /// Get the cooldown on the item specified in ticks
    pub fn get_cooldown(&self) -> &i32 {
        &self.cooldown
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundPluginMessage {
    channel: String,
    data: Vec<u8>,
}

impl ClientboundPluginMessage {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundPluginMessage(ClientboundPluginMessage {
            channel: read_String(r)?,
            data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the channel
    pub fn get_channel(&self) -> &String {
        &self.channel
    }

    /// Get the raw data
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct NamedSoundEffect {
    sound_name: String,
    sound_category: i32,
    x: i32,
    y: i32,
    z: i32,
    volume: f32,
    pitch: f32,
}

impl NamedSoundEffect {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::NamedSoundEffect(NamedSoundEffect {
            sound_name: read_String(r)?,
            sound_category: read_varint(r)?,
            x: read_i32(r)?,
            y: read_i32(r)?,
            z: read_i32(r)?,
            volume: read_f32(r)?,
            pitch: read_f32(r)?,
        }))
    }
    /// Get the name of the sound
    pub fn get_sound_name(&self) -> &String {
        &self.sound_name
    }

    /// Get the category of the sound
    pub fn get_sound_category(&self) -> &i32 {
        &self.sound_category
    }

    /// Get the X coordinate multiplied by 8
    pub fn get_x(&self) -> &i32 {
        &self.x
    }

    /// Get the Y coordinate multiplied by 8
    pub fn get_y(&self) -> &i32 {
        &self.y
    }

    /// Get the Z coordinate multiplied by 8
    pub fn get_z(&self) -> &i32 {
        &self.z
    }

    /// Get the volume
    pub fn get_volume(&self) -> &f32 {
        &self.volume
    }

    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayDisconnect {
    reason: String,
}

impl PlayDisconnect {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayDisconnect(PlayDisconnect {
            reason: read_String(r)?,
        }))
    }
    /// Get the reason in raw json format
    pub fn get_reason(&self) -> &String {
        &self.reason
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityStatus {
    entity_id: i32,
    status: u8,
}

impl EntityStatus {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityStatus(EntityStatus {
            entity_id: read_i32(r)?,
            status: read_u8(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the status of the entity
    pub fn get_status(&self) -> &u8 {
        &self.status
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Explosion {
    x: f32,
    y: f32,
    z: f32,
    radius: f32,
    affected_blocks: Vec<(i8, i8, i8)>,
    motion_x: f32,
    motion_y: f32,
    motion_z: f32,
}

#[derive(Debug, PartialEq, Clone)]
pub struct UnloadChunk {
    chunk_x: i32,
    chunk_z: i32,
}

impl UnloadChunk {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UnloadChunk(UnloadChunk {
            chunk_x: read_i32(r)?,
            chunk_z: read_i32(r)?,
        }))
    }
    /// Get the chunk's X coordinate
    pub fn get_chunk_x(&self) -> &i32 {
        &self.chunk_x
    }

    /// Get the chunk's Z coordinate
    pub fn get_chunk_z(&self) -> &i32 {
        &self.chunk_z
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ChangeGameState {
    action: u8,
    value: f32,
}

impl ChangeGameState {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChangeGameState(ChangeGameState {
            action: read_u8(r)?,
            value: read_f32(r)?,
        }))
    }
    /// Get the reason for the change as a byte
    pub fn get_action(&self) -> &u8 {
        &self.action
    }

    /// Get the value, its meaning depends on the action
    pub fn get_value(&self) -> &f32 {
        &self.value
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct KeepAlive {
    id: i32,
}

impl KeepAlive {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::KeepAlive(KeepAlive {
            id: read_varint(r)?,
        }))
    }
    /// Get the ID of the keep alive packet
    pub fn get_id(&self) -> &i32 {
        &self.id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ChunkData {
    data: Vec<u8>,
}

impl ChunkData {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ChunkData(ChunkData {
            data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get all the data contained in this packet. Currently it's decided that this library shouldn't try to interpret complex data structures that are likely dependent on the specific implementation, so the parsing of this packet is left up to the client.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Effect {
    effect_id: i32,
    location: u64,
    data: i32,
    disable_relative_volume: bool,
}

impl Effect {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Effect(Effect {
            effect_id: read_i32(r)?,
            location: read_u64(r)?,
            data: read_i32(r)?,
            disable_relative_volume: read_bool(r)?,
        }))
    }
    /// Get the ID of the effect
    pub fn get_effect_id(&self) -> &i32 {
        &self.effect_id
    }

    /// Get the data for this effect
    pub fn get_data(&self) -> &i32 {
        &self.data
    }

    /// Get whether to disable relative volume
    pub fn get_disable_relative_volume(&self) -> &bool {
        &self.disable_relative_volume
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Particle {
    particle_id: i32,
    use_long_distance: bool,
    x: f32,
    y: f32,
    z: f32,
    offset_x: f32,
    offset_y: f32,
    offset_z: f32,
    particle_data: f32,
    count: i32,
    id: Option<i32>,
    crack_data: Option<i32>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct JoinGame {
    entity_id: i32,
    gamemode: u8,
    dimension: i32,
    difficulty: u8,
    max_players: u8,
    level_type: String,
    reduced_debug: bool,
}

impl JoinGame {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::JoinGame(JoinGame {
            entity_id: read_i32(r)?,
            gamemode: read_u8(r)?,
            dimension: read_i32(r)?,
            difficulty: read_u8(r)?,
            max_players: read_u8(r)?,
            level_type: read_String(r)?,
            reduced_debug: read_bool(r)?,
        }))
    }
    /// Get the player's entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the player's gamemode
    pub fn get_gamemode(&self) -> &u8 {
        &self.gamemode
    }

    /// Get the dimension the player is in. Not the specific world (in case of servers with multiworld), but the kind of world
    pub fn get_dimension(&self) -> &i32 {
        &self.dimension
    }

    /// Get the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }

    /// Get the level type of the world the player joined in
    pub fn get_level_type(&self) -> &String {
        &self.level_type
    }

    /// Get whether to show reduced debug info
    pub fn get_reduced_debug(&self) -> &bool {
        &self.reduced_debug
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Map {
    data: Vec<u8>,
}

impl Map {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Map(Map {
            data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the raw data from this packet. Parsing this is very dependent on the specific client, and doing so would be out of scope for this library, therefore parsing this packet is left to the user of the library.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityRelativeMove {
    entity_id: i32,
    x: i16,
    y: i16,
    z: i16,
    on_ground: bool,
}

impl EntityRelativeMove {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityRelativeMove(EntityRelativeMove {
            entity_id: read_varint(r)?,
            x: read_i16(r)?,
            y: read_i16(r)?,
            z: read_i16(r)?,
            on_ground: read_bool(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the relative distanced moved in the X direction times 128
    pub fn get_x(&self) -> &i16 {
        &self.x
    }

    /// Get the relative distanced moved in the Y direction times 128
    pub fn get_y(&self) -> &i16 {
        &self.y
    }

    /// Get the relative distanced moved in the Z direction times 128
    pub fn get_z(&self) -> &i16 {
        &self.z
    }

    /// Get whether the entity is on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityLookRelativeMove {
    entity_id: i32,
    x: i16,
    y: i16,
    z: i16,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityLookRelativeMove {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityLookRelativeMove(EntityLookRelativeMove {
            entity_id: read_varint(r)?,
            x: read_i16(r)?,
            y: read_i16(r)?,
            z: read_i16(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the relative distanced moved in the X direction times 128
    pub fn get_x(&self) -> &i16 {
        &self.x
    }

    /// Get the relative distanced moved in the Y direction times 128
    pub fn get_y(&self) -> &i16 {
        &self.y
    }

    /// Get the relative distanced moved in the Z direction times 128
    pub fn get_z(&self) -> &i16 {
        &self.z
    }

    /// Get the yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }

    /// Get the pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }

    /// Get whether the entity is on the grouns
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityLook {
    entity_id: i32,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityLook {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityLook(EntityLook {
            entity_id: read_varint(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the (absolute) angle
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }

    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }

    /// Get whether on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Entity {
    entity_id: i32,
}

impl Entity {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Entity(Entity {
            entity_id: read_varint(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundVehicleMove {
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
}

impl ClientboundVehicleMove {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundVehicleMove(ClientboundVehicleMove {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
        }))
    }
    /// Get the X coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }

    /// Get the Y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }

    /// Get the Z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }

    /// Get the (absolute) angle
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }

    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct OpenSignEditor {
    position: (i32, i32, i32),
}

impl OpenSignEditor {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::OpenSignEditor(OpenSignEditor {
            position: read_position(r)?,
        }))
    }
    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerAbilities {
    flags: u8,
    flying_speed: f32,
    fov: f32,
}

impl PlayerAbilities {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerAbilities(PlayerAbilities {
            flags: read_u8(r)?,
            flying_speed: read_f32(r)?,
            fov: read_f32(r)?,
        }))
    }
    /// Get the player's allowed flying speed
    pub fn get_flying_speed(&self) -> &f32 {
        &self.flying_speed
    }

    /// Get the player's field of view modifier
    pub fn get_fov(&self) -> &f32 {
        &self.fov
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct CombatEvent {
    event: i32,
    duration_playerid: Option<i32>,
    entity_id: Option<i32>,
    message: Option<String>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerListItem {
    data: Vec<u8>,
}

impl PlayerListItem {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerListItem(PlayerListItem {
            data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the raw data from this packet. This library does not attempt to parse this packet.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerPositionAndLook {
    x: f64,
    y: f64,
    z: f64,
    yaw: f32,
    pitch: f32,
    flags: u8,
    teleport_id: i32,
}

impl PlayerPositionAndLook {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerPositionAndLook(PlayerPositionAndLook {
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_f32(r)?,
            pitch: read_f32(r)?,
            flags: read_u8(r)?,
            teleport_id: read_varint(r)?,
        }))
    }
    /// Get the x coordinate
    pub fn get_x(&self) -> &f64 {
        &self.x
    }

    /// Get the y coordinate
    pub fn get_y(&self) -> &f64 {
        &self.y
    }

    /// Get the z coordinate
    pub fn get_z(&self) -> &f64 {
        &self.z
    }

    /// Get the yaw
    pub fn get_yaw(&self) -> &f32 {
        &self.yaw
    }

    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }

    /// Get the raw flags bitmask
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }

    /// Get the teleport ID to be used in the serverbound TeleportConfirm packet.
    pub fn get_teleport_id(&self) -> &i32 {
        &self.teleport_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct UseBed {
    entity_id: i32,
    position: (i32, i32, i32),
}

impl UseBed {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UseBed(UseBed {
            entity_id: read_varint(r)?,
            position: read_position(r)?,
        }))
    }
    /// Get the entity ID of the player sleeping
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the (x, y, z) position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct DestroyEntities {
    entity_ids: Vec<i32>,
}

impl DestroyEntities {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::DestroyEntities(DestroyEntities {
            entity_ids: read_prefixed_varintarray(r)?,
        }))
    }
    /// Get the list of entity IDs that have been destroyed
    pub fn get_entity_ids(&self) -> &Vec<i32> {
        &self.entity_ids
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct RemoveEntityEffect {
    entity_id: i32,
    effect_id: u8,
}

impl RemoveEntityEffect {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::RemoveEntityEffect(RemoveEntityEffect {
            entity_id: read_varint(r)?,
            effect_id: read_u8(r)?,
        }))
    }
    /// Get the entity ID to remove the effect from
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ResourcePackSend {
    url: String,
    hash: String,
}

impl ResourcePackSend {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ResourcePackSend(ResourcePackSend {
            url: read_String(r)?,
            hash: read_String(r)?,
        }))
    }
    /// Get the URL to the resource pack
    pub fn get_url(&self) -> &String {
        &self.url
    }

    /// Get the expected SHA-1 hash of the resource pack
    pub fn get_hash(&self) -> &String {
        &self.hash
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Respawn {
    dimension: i32,
    difficulty: u8,
    gamemode: u8,
    level_type: String,
}

impl Respawn {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Respawn(Respawn {
            dimension: read_i32(r)?,
            difficulty: read_u8(r)?,
            gamemode: read_u8(r)?,
            level_type: read_String(r)?,
        }))
    }
    /// Get the integer value for the dimension the player is spawning in
    pub fn get_dimension(&self) -> &i32 {
        &self.dimension
    }

    /// Get the integer value for the difficulty
    pub fn get_difficulty(&self) -> &u8 {
        &self.difficulty
    }

    /// Get the integer value for the gamemode
    pub fn get_gamemode(&self) -> &u8 {
        &self.gamemode
    }

    /// Get the level type
    pub fn get_level_type(&self) -> &String {
        &self.level_type
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityHeadLook {
    entity_id: i32,
    head_yaw: i8,
}

impl EntityHeadLook {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityHeadLook(EntityHeadLook {
            entity_id: read_varint(r)?,
            head_yaw: read_i8(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the new head yaw
    pub fn get_head_yaw(&self) -> &i8 {
        &self.head_yaw
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct WorldBorder {
    data: Vec<u8>,
}

impl WorldBorder {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::WorldBorder(WorldBorder {
            data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get this packet's raw data. This library does not attempt to parse this packet
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Camera {
    entity_id: i32,
}

impl Camera {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Camera(Camera {
            entity_id: read_varint(r)?,
        }))
    }
    /// Get the entity ID to set the camera to
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ClientboundHeldItemChange {
    slot: u8,
}

impl ClientboundHeldItemChange {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::ClientboundHeldItemChange(ClientboundHeldItemChange {
            slot: read_u8(r)?,
        }))
    }
    /// Get the slot number which the player has selected
    pub fn get_slot(&self) -> &u8 {
        &self.slot
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct DisplayScoreboard {
    position: u8,
    name: String,
}

impl DisplayScoreboard {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::DisplayScoreboard(DisplayScoreboard {
            position: read_u8(r)?,
            name: read_String(r)?,
        }))
    }
    /// Get the raw integer representing the scoreboard's position
    pub fn get_position(&self) -> &u8 {
        &self.position
    }

    /// Get the name of the scoreboard
    pub fn get_name(&self) -> &String {
        &self.name
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityMetadata {
    entity_id: i32,
    metadata: Vec<u8>,
}

impl EntityMetadata {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityMetadata(EntityMetadata {
            entity_id: read_varint(r)?,
            metadata: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the entity ID of the entity which metadata is being updated
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the raw data for the metadata. This library does not attempt to parse the metadata.
    pub fn get_metadata(&self) -> &Vec<u8> {
        &self.metadata
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct AttachEntity {
    attached_entity_id: i32,
    holding_entity_id: i32,
}

impl AttachEntity {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::AttachEntity(AttachEntity {
            attached_entity_id: read_i32(r)?,
            holding_entity_id: read_i32(r)?,
        }))
    }
    /// Get the entity ID of the entity that has been attached
    pub fn get_attached_entity_id(&self) -> &i32 {
        &self.attached_entity_id
    }

    /// Get the entity ID of the entity that has been attached to
    pub fn get_holding_entity_id(&self) -> &i32 {
        &self.holding_entity_id
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityVelocity {
    entity_id: i32,
    x_velocity: i16,
    y_velocity: i16,
    z_velocity: i16,
}

impl EntityVelocity {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityVelocity(EntityVelocity {
            entity_id: read_varint(r)?,
            x_velocity: read_i16(r)?,
            y_velocity: read_i16(r)?,
            z_velocity: read_i16(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the X velocity
    pub fn get_x_velocity(&self) -> &i16 {
        &self.x_velocity
    }

    /// Get the Y velocity
    pub fn get_y_velocity(&self) -> &i16 {
        &self.y_velocity
    }

    /// Get the Z velocity
    pub fn get_z_velocity(&self) -> &i16 {
        &self.z_velocity
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityEquipment {
    entity_id: i32,
    slot_enum: i32,
    slot_data: Vec<u8>,
}

impl EntityEquipment {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityEquipment(EntityEquipment {
            entity_id: read_varint(r)?,
            slot_enum: read_varint(r)?,
            slot_data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the raw slot identification number
    pub fn get_slot_enum(&self) -> &i32 {
        &self.slot_enum
    }

    /// Get the raw slot data. This library does not attempt to parse it
    pub fn get_slot_data(&self) -> &Vec<u8> {
        &self.slot_data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct SetExperience {
    experience: f32,
    level: i32,
    total_experience: i32,
}

impl SetExperience {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetExperience(SetExperience {
            experience: read_f32(r)?,
            level: read_varint(r)?,
            total_experience: read_varint(r)?,
        }))
    }
    /// Get how filled up the experience bar is
    pub fn get_experience(&self) -> &f32 {
        &self.experience
    }

    /// Get the new level
    pub fn get_level(&self) -> &i32 {
        &self.level
    }

    /// Get the total experience
    pub fn get_total_experience(&self) -> &i32 {
        &self.total_experience
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateHealth {
    health: f32,
    food: i32,
    saturation: f32,
}

impl UpdateHealth {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::UpdateHealth(UpdateHealth {
            health: read_f32(r)?,
            food: read_varint(r)?,
            saturation: read_f32(r)?,
        }))
    }
    /// Get how much health the player has
    pub fn get_health(&self) -> &f32 {
        &self.health
    }

    /// Get how much food the player has
    pub fn get_food(&self) -> &i32 {
        &self.food
    }

    /// Get the saturation level
    pub fn get_saturation(&self) -> &f32 {
        &self.saturation
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct ScoreboardObjective {
    name: String,
    mode: u8,
    value: Option<String>,
    objective_type: Option<String>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct SetPassengers {
    entity_id: i32,
    passengers: Vec<i32>,
}

impl SetPassengers {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SetPassengers(SetPassengers {
            entity_id: read_varint(r)?,
            passengers: read_prefixed_varintarray(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the vec of all the passengers
    pub fn get_passengers(&self) -> &Vec<i32> {
        &self.passengers
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Teams {
    data: Vec<u8>,
}

impl Teams {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::Teams(Teams {
            data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the raw data, this library does not attempt to parse this packet.
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct UpdateScore {
    name: String,
    action: u8,
    objective_name: String,
    value: Option<i32>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct SpawnPosition {
    position: (i32, i32, i32),
}

impl SpawnPosition {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SpawnPosition(SpawnPosition {
            position: read_position(r)?,
        }))
    }
    /// Get the position
    pub fn get_position(&self) -> &(i32, i32, i32) {
        &self.position
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct TimeUpdate {
    world_age: i64,
    time_of_day: i64,
}

impl TimeUpdate {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::TimeUpdate(TimeUpdate {
            world_age: read_i64(r)?,
            time_of_day: read_i64(r)?,
        }))
    }
    /// Get the world's age in ticks
    pub fn get_world_age(&self) -> &i64 {
        &self.world_age
    }

    /// Get the current time in ticks (0 is sunrise, 6000 is noon, ...)
    pub fn get_time_of_day(&self) -> &i64 {
        &self.time_of_day
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct Title {
    action: i32,
    text: Option<String>,
    times: Option<(i32, i32, i32)>,
}

#[derive(Debug, PartialEq, Clone)]
pub struct SoundEffect {
    sound_id: i32,
    sound_category: i32,
    x: i32,
    y: i32,
    z: i32,
    volume: f32,
    pitch: f32,
}

impl SoundEffect {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::SoundEffect(SoundEffect {
            sound_id: read_varint(r)?,
            sound_category: read_varint(r)?,
            x: read_i32(r)?,
            y: read_i32(r)?,
            z: read_i32(r)?,
            volume: read_f32(r)?,
            pitch: read_f32(r)?,
        }))
    }
    /// Get the raw sound effect ID. Note that the meaning of this is liable to change between MC releases.
    pub fn get_sound_id(&self) -> &i32 {
        &self.sound_id
    }

    /// Get the raw sound category ID.
    pub fn get_sound_category(&self) -> &i32 {
        &self.sound_category
    }

    /// Get the X effect multiplied by 8
    pub fn get_x(&self) -> &i32 {
        &self.x
    }

    /// Get the Y effect multiplied by 8
    pub fn get_y(&self) -> &i32 {
        &self.y
    }

    /// Get the Z effect multiplied by 8
    pub fn get_z(&self) -> &i32 {
        &self.z
    }

    /// Get the volume where 1.0 is 100%
    pub fn get_volume(&self) -> &f32 {
        &self.volume
    }

    /// Get the pitch
    pub fn get_pitch(&self) -> &f32 {
        &self.pitch
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct PlayerListHeaderFooter {
    header: String,
    footer: String,
}

impl PlayerListHeaderFooter {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::PlayerListHeaderFooter(PlayerListHeaderFooter {
            header: read_String(r)?,
            footer: read_String(r)?,
        }))
    }
    /// Get the raw json data for the header
    pub fn get_header(&self) -> &String {
        &self.header
    }

    /// Get the raw json data for the footer
    pub fn get_footer(&self) -> &String {
        &self.footer
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct CollectItem {
    collected_entity_id: i32,
    collector_entity_id: i32,
    item_count: i32,
}

impl CollectItem {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::CollectItem(CollectItem {
            collected_entity_id: read_varint(r)?,
            collector_entity_id: read_varint(r)?,
            item_count: read_varint(r)?,
        }))
    }
    /// Get the entity ID of the collected item
    pub fn get_collected_entity_id(&self) -> &i32 {
        &self.collected_entity_id
    }

    /// Get the entity ID of the person picking up the item
    pub fn get_collector_entity_id(&self) -> &i32 {
        &self.collector_entity_id
    }

    /// Get how many items were picked up
    pub fn get_item_count(&self) -> &i32 {
        &self.item_count
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityTeleport {
    entity_id: i32,
    x: f64,
    y: f64,
    z: f64,
    yaw: i8,
    pitch: i8,
    on_ground: bool,
}

impl EntityTeleport {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityTeleport(EntityTeleport {
            entity_id: read_varint(r)?,
            x: read_f64(r)?,
            y: read_f64(r)?,
            z: read_f64(r)?,
            yaw: read_i8(r)?,
            pitch: read_i8(r)?,
            on_ground: read_bool(r)?,
        }))
    }
    /// Get the entity ID of the entity teleported
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the X coordinate the entity moved to
    pub fn get_x(&self) -> &f64 {
        &self.x
    }

    /// Get the Y coordinate the entity moved to
    pub fn get_y(&self) -> &f64 {
        &self.y
    }

    /// Get the Z coordinate the entity moved to
    pub fn get_z(&self) -> &f64 {
        &self.z
    }

    /// Get the (absolute) yaw
    pub fn get_yaw(&self) -> &i8 {
        &self.yaw
    }

    /// Get the (absolute) pitch
    pub fn get_pitch(&self) -> &i8 {
        &self.pitch
    }

    /// Get whether the entity is now on the ground
    pub fn get_on_ground(&self) -> &bool {
        &self.on_ground
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityProperties {
    data: Vec<u8>,
}

impl EntityProperties {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityProperties(EntityProperties {
            data: read_bytearray_to_end(r)?,
        }))
    }
    /// Get the raw data for this packet. This library does not attempt to parse the packet
    pub fn get_data(&self) -> &Vec<u8> {
        &self.data
    }

}

#[derive(Debug, PartialEq, Clone)]
pub struct EntityEffect {
    entity_id: i32,
    effect_id: u8,
    amplifier: i8,
    duration: i32,
    flags: u8,
}

impl EntityEffect {
    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {
        Ok(ClientboundPacket::EntityEffect(EntityEffect {
            entity_id: read_varint(r)?,
            effect_id: read_u8(r)?,
            amplifier: read_i8(r)?,
            duration: read_varint(r)?,
            flags: read_u8(r)?,
        }))
    }
    /// Get the entity ID
    pub fn get_entity_id(&self) -> &i32 {
        &self.entity_id
    }

    /// Get the raw effect ID integer enum
    pub fn get_effect_id(&self) -> &u8 {
        &self.effect_id
    }

    /// Get the amplifier = effect level - 1
    pub fn get_amplifier(&self) -> &i8 {
        &self.amplifier
    }

    /// Get the duration of the effect in seconds
    pub fn get_duration(&self) -> &i32 {
        &self.duration
    }

    /// Get the raw flags byte
    pub fn get_flags(&self) -> &u8 {
        &self.flags
    }

}

