#!/usr/bin/env clojure
(ns ozelot.packets
  (:use [packet-definitions :only [packets]]
        [clojure.java.io]))

;;;; What this file does is given a bunch of packet definitions, create the
;;;; .clientbound.generated.rs and .serverbound.generated.rs files, which contain
;;;; the definitions of packets and other general fields.
;;;;
;;;; This way we only have to define packets in once, in packet_definitions.clj.
;;;; Is this the cleanest solution to the problem? No, but it works well, and
;;;; was easy to write, and it avoids adding additional dependencies for
;;;; building ozelot.


(defn long-str [& x] (clojure.string/join "\n" x))

(def client-recv-file "./.client_recv.generated.rs")
(def client-send-file "./.client_send.generated.rs")
(def server-recv-file "./.server_recv.generated.rs")
(def server-send-file "./.server_send.generated.rs")
(def warning (long-str
               "/* This file is automatically generated by packets.clj"
               "Do not manually edit this file, if you wish to make"
               "changes here, then edit and rerun packets.clj */\n\n"))
; Clear the files
(spit client-recv-file warning)
(spit client-send-file warning)
;(spit server-recv-file warning)
;(spit server-send-file warning)

;; A list of the clientbound packets
(def clientbound-packets
  (->> packets
       :clientbound
       vals
       (apply concat)))

;; A list of the serverbound packets
(def serverbound-packets
  (->> packets
       :serverbound
       ; For each packet, we assoc in the :state (serverbound, clientbound)
       (map (fn [[key value]]
              (map (fn [packet]
                     (assoc packet :state key))
                   value)))
       (apply concat)))

;; Given the fields of a given packet, return a string containing the fields
;; in the rust definition format, i.e. %name: %type, and so on
(defn fields-type-str [fields]
  (apply str
         (map
           (fn [{x :name y :type}]
             (format "    %s: %s,\n" x y))
           fields)))

;; Given the fields of a given packet, return a string containing the fields
;; in the %name: %name format, e.g. for use in an fn new
(defn fields-name-str [fields]
  (apply str
         (map
           (fn [{name :name}]
             (format "            %s: %s,\n" name name))
           fields)))

;; Given the fields of a given packet, return a string containing the fields
;; in the rust packet definition format, i.e. fn something(%s: %s, %s: %s, ... etc)
;; (i.e it returns everything within the parenthese)
;(defn fields-fn-definition-str [fields]
 ; (apply str
  ;       (map
   ;        (fn [{name :name type :type}]
    ;         (format "%s: %s," name type))
     ;      fields)))
;(defn long-str [& x] (clojure.string/join "\n" x))
(defn fields-fn-definition-str [fields]
  (apply (fn [& x] (clojure.string/join ", " x))
         (map
           (fn [{name :name type :type}]
             (format "%s: %s" name type))
           fields)))

(defn write-fields-str [fields]
  (apply str
         (map
           (fn [{name :name type :type read :read}]
             (format "        write_%s(&self.%s, &mut ret)?;\n"
                     (if (nil? read)
                       type
                       read)
                     name))
           fields)))

;; Given the fields of a packet, return a string containing functions that
;; read all those fields, i.e. for use inside a 'new' function for the packet
(defn read-fields-str [fields]
  (apply str
         (map
           (fn [{name :name type :type read :read}]
             ; 12 spaces = 3 indentation levels
             (format "            %s: read_%s(r)?,\n"
                     name
                     ; If :read is specified use that function to read from
                     ; else use the read_:type function
                     (if (nil? read)
                       type
                       read)))
           fields)))

(defn client-recv-impl-getters-str [fields]
  (apply str
         (map
           (fn [{name :name type :type getter-docs :getter}]
             (if (nil? getter-docs)
               ""
               (format (long-str "\n    /// %s"
                                 "    pub fn get_%s(&self) -> &%s {"
                                 "        &self.%s"
                                 "    }\n")
                       getter-docs name type name)))
           fields)))

;; Create the impl for a Clientbound packet as a string
(defn client-recv-impl-str [name fields make-fn-new]
  (if (nil? make-fn-new)
    (format (long-str "impl %s {"
                      "    fn new<R: Read>(r: &mut R) -> io::Result<ClientboundPacket> {"
                      "        Ok(ClientboundPacket::%s(%s {"
                      "%s        }))"
                      "    }%s"
                      "}\n\n")
            name name name (read-fields-str fields) (client-recv-impl-getters-str fields))
    ""))

;; Provides the struct definitions for all the clientbound packets
(def client-recv-structs-definitions
  (for [{name :name
         ; Whether to make the 'new' function for this struct
         ; Some packets are slightly problematic so we don't make it
         make-fn-new :make-fn-new
         fields :fields}
        clientbound-packets]
    (let [fields-str (fields-type-str fields)
          struct-def (format "#[derive(Debug, PartialEq, Clone)]\npub struct %s {\n%s}\n\n" name fields-str)
          impl-def (client-recv-impl-str name fields make-fn-new)]
      (str struct-def impl-def)
      )))

;; Provides the ClientboundPacket enum definition
(def client-recv-packet-enum
  (str "#[derive(Debug, PartialEq, Clone)]\npub enum ClientboundPacket {\n"
       (apply str
              (for [{name :name} clientbound-packets]
                (format "    %s(%s),\n" name name)
                ))
       "}\n\n"))


;; Create the match strings for the packet_id for the given packets
;; e.g. match packet_id { 1 => StatusPong::new(&mut cursor)?, }
;; This function should only be called by enum-match-str
(defn match-id-str [packets]
  (if (empty? packets)
    "                return io_error!(\"No packet available in this state\");\n"
    (str "            match packet_id {\n"
         (apply str
                (for [{name :name id :id} packets]
                  (format "                %s => %s::new(r)?,\n" id name)))
         "                _ => return io_error!(\"No packet with id {} in state {:?}\", packet_id, state),"
         "            }\n")))

;; Given some packets, creates the match statement that matches 'id' and
;; 'clientstate' to one of the packet's new function
(defn enum-match-str [packets]
  (format "        Ok(match state {\n%s        })"
          (apply str
                 (for [[state packets] packets]
                   (format "            &ClientState::%s => {\n%s            },\n" state (match-id-str packets))
                   ))))

;; Create the contents of the match for each kind of packet, matching the
;; packet type to a &str with the name of the packet
(defn packet-name-match-str [packets]
  (apply str
         (for [{name :name} packets]
           (format "            &ClientboundPacket::%s(_) => \"%s\",\n"
                   name name))))


(def client-recv-packet-enum-impl
  (long-str "impl ClientboundPacket {"
            "    /// Given a reader over precisely one packet, parse it into a packet."
            "    /// Assumes that encryption/compression has already been stripped,"
            "    /// and the first byte from the reader is the one that specifies the"
            "    /// the packet id."
            "    pub fn parse<R: Read>(r: &mut R, state: &ClientState) -> io::Result<Self> {"
            "        let packet_id = read_varint(r)?;"
            "        //println!(\"packet_id = {}, state = {:?}\", packet_id, state);"
            (enum-match-str (packets :clientbound))
            "    }"
            "    /// Return the name of the packet type"
            "    pub fn get_packet_name(&self) -> &str {"
            "        match self {"
            (packet-name-match-str clientbound-packets)
            "        }"
            "    }"
            "}\n\n"
            ))


(spit client-recv-file client-recv-packet-enum :append true)
(spit client-recv-file client-recv-packet-enum-impl :append true)
(doseq [struct client-recv-structs-definitions] (spit client-recv-file struct :append true))


;; Crates the fn new for a client-send packet
(defn client-send-fn-new [fields name make-fn-new]
    (format (long-str "    pub fn %s(%s) -> Self {"
                      "        %s {"
                      "%s        }"
                      "    }"
                      )
            ; If make-fn-new is false, we call the function new_raw instead of new
            (if (nil? make-fn-new) "new" "new_raw")
            (fields-fn-definition-str fields)
            name
            (fields-name-str fields))
    )

;; Creates the fn to_u8 for a client-send packet
(defn client-send-fn-to-u8 [name fields make-fn-to-u8]
  (if (nil? make-fn-to-u8)
    (format (long-str "    fn to_u8(&self) -> io::Result<Vec<u8>> {"
                      "        let mut ret = Vec::new();"
                      "        write_varint(&%s::get_id(), &mut ret)?;"
                      "%s        Ok(ret)"
                      "    }"
                      )
            name
            (write-fields-str fields))
    (long-str "    fn to_u8(&self) -> io::Result<Vec<u8>> {"
              "        /* This is because we can't split the implementation of a trait"
              "        * across more than one impl block, so when we want to create a custom"
              "        * to_u8() implementation, we name it to_u8_custom and then just have this"
              "        * default to calling that */"
              "        self.to_u8_custom()"
              "    }"
              )))

;; Gives all the impl definitions for a packet in the client-send context.
(defn client-send-impl [name fields id state make-fn-new make-fn-to-u8]
  (format (long-str "impl %s {"
                    "%s"
                    "}"
                    "impl Sendable for %s {"
                    "%s"
                    "    fn get_state() -> ClientState {"
                    "        ClientState::%s"
                    "    }"
                    "    fn get_id() -> i32 {"
                    "        %s"
                    "    }"
                    "}\n")
          name
          (client-send-fn-new fields name make-fn-new)
          name
          (client-send-fn-to-u8 name fields make-fn-to-u8)
          state
          id
          ))

(def client-send-structs-definitions
  (for [{name :name
         id :id
         fields :fields
         state :state
         make-fn-new :make-fn-new
         make-fn-to-u8 :make-fn-to-u8}
        serverbound-packets]
    (let [fields-type-str (fields-type-str fields)
          client-send-impl (client-send-impl name fields id state make-fn-new make-fn-to-u8)
          struct-def (format (long-str "#[derive(Debug, PartialEq, Clone)]"
                                       "pub struct %s {"
                                       "%s}"
                                       "%s\n")
                             name fields-type-str client-send-impl)]
      struct-def)))

(doseq [struct client-send-structs-definitions] (spit client-send-file struct :append true))

